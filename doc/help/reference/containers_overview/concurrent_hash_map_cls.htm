
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0014)about:internet -->
<html xmlns:MSHelp="http://www.microsoft.com/MSHelp/" lang="en-us" xml:lang="en-us"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="DC.Type" content="reference">
<meta name="DC.Title" content="concurrent_hash_map Template Class">
<meta name="DC.subject" content="concurrent_hash_map Template Class">
<meta name="keywords" content="concurrent_hash_map Template Class">
<meta name="DC.Relation" scheme="URI" content="../../reference/containers_overview.htm">
<meta name="DC.Relation" scheme="URI" content="../../reference/containers_overview/concurrent_hash_map_cls/whole_table_operations.htm">
<meta name="DC.Relation" scheme="URI" content="../../reference/containers_overview/concurrent_hash_map_cls/concurrent_access.htm">
<meta name="DC.Relation" scheme="URI" content="../../reference/containers_overview/concurrent_hash_map_cls/concurrent_operations.htm">
<meta name="DC.Relation" scheme="URI" content="../../reference/containers_overview/concurrent_hash_map_cls/parallel_iteration_container.htm">
<meta name="DC.Relation" scheme="URI" content="../../reference/containers_overview/concurrent_hash_map_cls/capacity_map_cls.htm">
<meta name="DC.Relation" scheme="URI" content="../../reference/containers_overview/concurrent_hash_map_cls/iterators_hash_map_cls.htm">
<meta name="DC.Relation" scheme="URI" content="../../reference/containers_overview/concurrent_hash_map_cls/global_funcs.htm">
<meta name="DC.Relation" scheme="URI" content="../../reference/containers_overview/concurrent_hash_map_cls/tbb_hash_compare_cls.htm">
<meta name="DC.Relation" scheme="URI" content="concurrent_hash_map_cls/concurrent_operations.htm">
<meta name="DC.Format" content="XHTML">
<meta name="DC.Identifier" content="concurrent_hash_map_cls">
<meta name="DC.Language" content="en-US">
<link rel="stylesheet" type="text/css" href="../../intel_css_styles.css">
<title>concurrent_hash_map Template Class</title>
</head>
<body id="concurrent_hash_map_cls">
 <!-- ==============(Start:NavScript)================= -->
 <script src="../../NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
 <script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>
 <!-- ==============(End:NavScript)================= -->
<a name="concurrent_hash_map_cls"><!-- --></a>

 
  <h1 class="topictitle1">concurrent_hash_map Template Class</h1>
 
   
  <div> 
	 <div class="section"><h2 class="sectiontitle">Summary</h2> 
		 
		<p>Template class for associative container with
		  concurrent access. 
		</p>
 
	 </div>
 
	 <div class="section"><h2 class="sectiontitle">Syntax</h2> 
		 
		<pre>template &lt; typename Key, typename T, 
         typename HashCompare=tbb_hash_compare&lt;Key&gt;, 
         typename A=tbb_allocator&lt;std::pair &lt; Key, T&gt; &gt; &gt;
         class concurrent_hash_map;
</pre> 
	 </div>
 
	 <div class="section"><h2 class="sectiontitle">Header</h2> 
		 
		<pre>#include "tbb/concurrent_hash_map.h"</pre> 
	 </div>
 
	 <div class="section"><h2 class="sectiontitle">Description</h2> 
		 
		<p>A 
		  <samp class="codeph">concurrent_hash_map</samp> maps keys to values in a way that
		  permits multiple threads to concurrently access values. The keys are unordered.
		  There is at most one element in a 
		  <samp class="codeph">concurrent_hash_map</samp> for each key. The key may have
		  other elements in flight but not in the map, as described in Concurrent
		  Operations. The interface resembles typical STL associative containers, but
		  with some differences critical to supporting concurrent access. It meets the
		  Container Requirements of the ISO C++ standard. Types 
		  <samp class="codeph">Key</samp> and 
		  <samp class="codeph">T</samp> must model the CopyConstructible concept. Type 
		  <samp class="codeph">HashCompare</samp> specifies how keys are hashed and compared
		  for equality. It must model the HashCompare concept in the table below. 
		</p>
 
		
<div class="tablenoborder"><a name="tbl1"><!-- --></a><table cellpadding="4" summary="" id="tbl1" width="100%" frame="border" border="1" cellspacing="0" rules="all"><caption><span class="tablecap">HashCompare Concept</span></caption> 
		   
		   
		  <thead align="left"> 
			 <tr> 
				<th class="cellrowborder" valign="top" width="NaN%" id="d2092e82"> 
				  <p><strong>Pseudo-Signature</strong> 
				  </p>
 
				</th>
 
				<th class="cellrowborder" valign="top" width="NaN%" id="d2092e90"> 
				  <p><strong>Semantics</strong> 
				  </p>
 
				</th>
 
			 </tr>
 
		  </thead>
 
		  <tbody> 
			 <tr> 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d2092e82 "> 
				  <p><samp class="codeph">HashCompare::HashCompare( const
						HashCompare&amp; )</samp> 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d2092e90 "> 
				  <p>Copy constructor. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d2092e82 "> 
				  <p><samp class="codeph">HashCompare::~HashCompare
						()</samp> 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d2092e90 "> 
				  <p>Destructor. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d2092e82 "> 
				  <p><samp class="codeph">bool HashCompare::equal( const
						Key&amp; j, const Key&amp; k ) const 
					 </samp> 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d2092e90 "> 
				  <p>True if keys are equal. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d2092e82 "> 
				  <p><samp class="codeph">size_t HashCompare::hash( const
						Key&amp; k ) const 
					 </samp> 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d2092e90 "> 
				  <p>Hashcode for key. 
				  </p>
 
				</td>
 
			 </tr>
 
		  </tbody>
 
		</table>
</div>
 
		<div class="Note"><h3 class="NoteTipHead">
					Caution</h3> 
		  <p>As for most hash tables, if two keys are equal,
			 they must hash to the same hash code. That is for a given HashCompare h and any
			 two keys 
			 <samp class="codeph">j 
			 </samp>and 
			 <samp class="codeph">k</samp>, the following assertion must hold: 
			 <samp class="codeph">"!h.equal(j,k) || h.hash(j)==h.hash(k)"</samp>. The
			 importance of this property is the reason that 
			 <samp class="codeph">concurrent_hash_map</samp> makes key equality and hashing
			 function travel together in a single object instead of being separate objects.
			 The hash code of a key must not change while the hash table is non-empty. 
		  </p>
 
		</div> 
		<div class="Note"><h3 class="NoteTipHead">
					Caution</h3> 
		  <p>Good performance depends on having good
			 pseudo-randomness in the low-order bits of the hash code. 
		  </p>
 
		</div> 
	 </div>
 
	 <div class="section"><h2 class="sectiontitle">Example</h2> 
		 
		<p>When keys are pointers, simply casting the pointer to a hash code may
		  cause poor performance because the low-order bits of the hash code will be
		  always zero if the pointer points to a type with alignment restrictions. A way
		  to remove this bias is to divide the casted pointer by the size of the type, as
		  indicated below in 
		  <samp class="codeph"><span style="color:blue"><strong><em>bold italic
					 font</em></strong></span></samp>. 
		</p>
 
		<pre>
           size_t MyHashCompare::hash( Key* key ) const {
            return reinterpret_cast&lt;size_t&gt;(key)<span style="color:blue"><strong><em>/sizeof(Key)</em></strong></span>;        
           }   
          </pre> 
	 </div>
 
	 <div class="section"><h2 class="sectiontitle">Members</h2> 
		
		<p> In the following synopsis, methods shown in 
		  <samp class="codeph"><span style="color:blue"><strong>bold font</strong></span></samp>
		  may be concurrently invoked.
		</p>
 
		<pre>
        namespace tbb {
    template&lt;typename Key, typename T, typename HashCompare, 
             typename Alloc=tbb_allocator&lt;std::pair&lt;Key,T&gt; &gt; &gt;
    class concurrent_hash_map {
    public:
        <em>// types</em>
        typedef Key key_type;
        typedef T mapped_type;
        typedef std::pair&lt;const Key,T&gt; value_type;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef value_type* pointer;
        typedef const value_type* const_pointer;
        typedef value_type&amp; reference;
        typedef Alloc allocator_type;

        <em>// whole-table operations</em>
        concurrent_hash_map( 
            const allocator_type&amp; a=allocator_type() );
        concurrent_hash_map( 
            size_type n, 
            const allocator_type &amp;a = allocator_type() );
        concurrent_hash_map( 
            const concurrent_hash_map&amp;, 
            const allocator_type&amp; a=allocator_type() );
        template&lt;typename InputIterator&gt;
            concurrent_hash_map(
                InputIterator first, InputIterator last, 
                const allocator_type&amp; a = allocator_type())
        ~concurrent_hash_map();
        concurrent_hash_map operator=(const concurrent_hash_map&amp;);
        void rehash( size_type n=0 );
        void clear();
        allocator_type get_allocator() const;

        <em>// concurrent access</em>
        class const_accessor;
        class accessor;

        <em>// concurrent operations on a table</em>
        bool <span style="color:blue"><strong>find</strong></span>( const_accessor&amp; result, const Key&amp; key ) const;
        bool <span style="color:blue"><strong>find</strong></span>( accessor&amp; result, const Key&amp; key );
        bool <span style="color:blue"><strong>insert</strong></span>( const_accessor&amp; result, const Key&amp; key );
        bool <span style="color:blue"><strong>insert</strong></span>( accessor&amp; result, const Key&amp; key );
        bool <span style="color:blue"><strong>insert</strong></span>( const_accessor&amp; result, const value_type&amp; value );
        bool <span style="color:blue"><strong>insert</strong></span>( accessor&amp; result, const value_type&amp; value );
        bool <span style="color:blue"><strong>insert</strong></span>( const value_type&amp; value );
        template&lt;typename I&gt; void insert( I first, I last );
        bool <span style="color:blue"><strong>erase</strong></span>( const Key&amp; key );
        bool <span style="color:blue"><strong>erase</strong></span>( const_accessor&amp; item_accessor );
        bool <span style="color:blue"><strong>erase</strong></span>( accessor&amp; item_accessor );

        <em>// parallel iteration</em>
        typedef <em>implementation-defined</em> range_type;
        typedef <em>implementation-defined</em> const_range_type;
        range_type range( size_t grainsize=1 );
        const_range_type range( size_t grainsize=1 ) const;

        <em>// capacity</em>
        size_type size() const;
        bool empty() const;
        size_type max_size() const;
        size_type bucket_count() const;

        <em>// iterators</em>
        typedef <em>implementation-defined</em> iterator;
        typedef <em>implementation-defined</em> const_iterator;
        iterator begin();
        iterator end();
        const_iterator begin() const;
        const_iterator end() const;
        std::pair&lt;iterator, iterator&gt; equal_range( const Key&amp; key );
        std::pair&lt;const_iterator, const_iterator&gt; 
            equal_range( const Key&amp; key ) const;
    };

    template&lt;typename Key, typename T, typename HashCompare, 
             typename A1, typename A2&gt;
    bool operator==(
        const concurrent_hash_map&lt;Key,T,HashCompare,A1&gt; &amp;a, 
        const concurrent_hash_map&lt;Key,T,HashCompare,A2&gt; &amp;b);

    template&lt;typename Key, typename T, typename HashCompare, 
             typename A1, typename A2&gt;
    bool operator!=(const    
        concurrent_hash_map&lt;Key,T,HashCompare,A1&gt; &amp;a, 
        const concurrent_hash_map&lt;Key,T,HashCompare,A2&gt; &amp;b);

    template&lt;typename Key, typename T, typename HashCompare, 
             typename A&gt;
    void swap(concurrent_hash_map&lt;Key,T,HashCompare,A&gt;&amp; a,    
              concurrent_hash_map&lt;Key,T,HashCompare,A&gt;&amp; b)
}
</pre> 
	 </div>
 
	 <div class="section"><h2 class="sectiontitle">Exception Safety</h2> 
		 The following
		functions must not throw exceptions: 
		<ul type="disc"> 
		  <li>The hash function 
		  </li>
 
		  <li>The destructors for types 
			 <samp class="codeph">Key</samp> and 
			 <samp class="codeph">T</samp>. 
		  </li>
 
		</ul>
 The following hold true: 
		<ul type="disc"> 
		  <li>If an exception happens during an insert operation, the operation
			 has no effect. 
		  </li>
 
		  <li>If an exception happens during an assignment operation, the
			 container may be in a state where only some of the items were assigned, and
			 methods 
			 <samp class="codeph">size()</samp> and 
			 <samp class="codeph">empty()</samp> may return invalid answers. 
		  </li>
 
		</ul>
 
	 </div>
 
  </div>
 
  
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="../../reference/containers_overview.htm">Containers Overview</a></div>
</div>
<div class="See Also">
<ul class="ullinks">
<li class="ulchildlink"><a href="../../reference/containers_overview/concurrent_hash_map_cls/whole_table_operations.htm">Whole Table Operations</a><br>
</li>
<li class="ulchildlink"><a href="../../reference/containers_overview/concurrent_hash_map_cls/concurrent_access.htm">Concurrent Access</a><br>
</li>
<li class="ulchildlink"><a href="../../reference/containers_overview/concurrent_hash_map_cls/concurrent_operations.htm">Concurrent Operations</a><br>
</li>
<li class="ulchildlink"><a href="../../reference/containers_overview/concurrent_hash_map_cls/parallel_iteration_container.htm">Parallel Iteration</a><br>
</li>
<li class="ulchildlink"><a href="../../reference/containers_overview/concurrent_hash_map_cls/capacity_map_cls.htm">Capacity</a><br>
</li>
<li class="ulchildlink"><a href="../../reference/containers_overview/concurrent_hash_map_cls/iterators_hash_map_cls.htm">Iterators</a><br>
</li>
<li class="ulchildlink"><a href="../../reference/containers_overview/concurrent_hash_map_cls/global_funcs.htm">Global Functions</a><br>
</li>
<li class="ulchildlink"><a href="../../reference/containers_overview/concurrent_hash_map_cls/tbb_hash_compare_cls.htm">tbb_hash_compare Class</a><br>
</li>
</ul>

<h2>See Also</h2>
<div class="linklist">
<div><a href="concurrent_hash_map_cls/concurrent_operations.htm">Concurrent Operations 
		  </a></div></div>
</div> 

</body>
</html>
