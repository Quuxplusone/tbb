
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0014)about:internet -->
<html xmlns:MSHelp="http://www.microsoft.com/MSHelp/" lang="en-us" xml:lang="en-us"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="DC.Type" content="reference">
<meta name="DC.Title" content="ReaderWriterMutex Concept">
<meta name="DC.subject" content="ReaderWriterMutex Concept">
<meta name="keywords" content="ReaderWriterMutex Concept">
<meta name="DC.Relation" scheme="URI" content="../../../reference/synchronization/mutexes.htm">
<meta name="DC.Format" content="XHTML">
<meta name="DC.Identifier" content="readerwritermutex_concept">
<meta name="DC.Language" content="en-US">
<link rel="stylesheet" type="text/css" href="../../../intel_css_styles.css">
<title>ReaderWriterMutex Concept</title>
</head>
<body id="readerwritermutex_concept">
 <!-- ==============(Start:NavScript)================= -->
 <script src="../../../NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
 <script language="JavaScript1.2" type="text/javascript">WriteNavLink(3);</script>
 <!-- ==============(End:NavScript)================= -->
<a name="readerwritermutex_concept"><!-- --></a>

 
  <h1 class="topictitle1">ReaderWriterMutex Concept</h1>
 
   
  <div> 
	 <div class="section"> 
		<p>The ReaderWriterMutex concept extends the Mutex
		  Concept to include the notion of reader-writer locks. It introduces a boolean
		  parameter 
		  <samp class="codeph">write</samp> that specifies whether a writer lock
		  (<samp class="codeph">write</samp> =true) or reader lock (<samp class="codeph">write</samp> =false)
		  is being requested. Multiple reader locks can be held simultaneously on a
		  ReaderWriterMutex if it does not have a writer lock on it. A writer lock on a
		  ReaderWriterMutex excludes all other threads from holding a lock on the mutex
		  at the same time. 
		</p>
 
		<p> The following table shows the requirements for a
		  ReaderWriterMutex 
		  <samp class="codeph">RW</samp>. They form a superset of the Mutex Concept. 
		</p>
 
		
<div class="tablenoborder"><a name="tbl28"><!-- --></a><table cellpadding="4" summary="" id="tbl28" width="100%" frame="border" border="1" cellspacing="0" rules="all"><caption><span class="tablecap">ReaderWriterMutex Concept</span></caption> 
		   
		   
		  <thead align="left">
			 <tr> 
				<th class="cellrowborder" valign="top" width="NaN%" id="d6937e52"> 
				  <p>Pseudo-Signature 
				  </p>
 
				</th>
 
				<th class="cellrowborder" valign="top" width="NaN%" id="d6937e58"> 
				  <p>Semantics 
				  </p>
 
				</th>
 
			 </tr>
</thead>

		  <tbody> 
			 <tr> 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e52 "> 
				  <p><samp class="codeph">RW()</samp> 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e58 "> 
				  <p>Construct unlocked mutex. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e52 "> 
				  <p><samp class="codeph">~RW()</samp> 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e58 "> 
				  <p>Destroy unlocked mutex. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e52 "> 
				  <p><samp class="codeph">typename RW::scoped_lock</samp> 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e58 "> 
				  <p>Corresponding scoped-lock type. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e52 "> 
				  <p><samp class="codeph">RW::scoped_lock()</samp> 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e58 "> 
				  <p>Construct lock without acquiring mutex. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e52 "> 
				  <p><samp class="codeph">RW::scoped_lock(RW&amp;, bool
						write=true)</samp> 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e58 "> 
				  <p>Construct lock and acquire lock on mutex. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e52 "> 
				  <p><samp class="codeph">RW::~scoped_lock()</samp> 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e58 "> 
				  <p>Release lock (if acquired). 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e52 "> 
				  <p><samp class="codeph">RW::scoped_lock::acquire(RW&amp;,bool
						write=true)</samp> 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e58 "> 
				  <p>Acquire lock on mutex. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e52 "> 
				  <p><samp class="codeph">bool
						RW::scoped_lock::try_acquire(RW&amp;, bool write=true)</samp> 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e58 "> 
				  <p>Try to acquire lock on mutex. Return 
					 <samp class="codeph">true</samp> if lock acquired, 
					 <samp class="codeph">false</samp> otherwise. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e52 "> 
				  <p><samp class="codeph">RW::scoped_lock::release()</samp>
					 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e58 "> 
				  <p>Release lock. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e52 "> 
				  <p><samp class="codeph">bool
						RW::scoped_lock::upgrade_to_writer()</samp> 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e58 "> 
				  <p>Change reader lock to writer lock. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e52 "> 
				  <p><samp class="codeph">bool
						RW::scoped_lock::downgrade_to_reader()</samp> 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e58 "> 
				  <p>Change writer lock to reader lock. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e52 "> 
				  <p><samp class="codeph">static const bool RW::is_rw_mutex =
						true</samp> 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e58 "> 
				  <p>True. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e52 "> 
				  <p><samp class="codeph">static const bool
						RW::is_recursive_mutex</samp> 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e58 "> 
				  <p>True if mutex is recursive; false
					 otherwise. For all current reader-writer mutexes, false. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e52 "> 
				  <p><samp class="codeph">static const bool
						RW::is_fair_mutex</samp> 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="NaN%" headers="d6937e58 "> 
				  <p>True if mutex is fair; false otherwise. 
				  </p>
 
				</td>
 
			 </tr>
 
		  </tbody>
 
		</table>
</div>
 
	 </div>
 
	 
<div class="tablenoborder"><table cellpadding="4" summary="" frame="border" border="1" cellspacing="0" rules="all"><span class="tabledesc">The following table provides explain the semantics of the
		  ReaderWriterMutex concept in detail. 
		</span><thead align="left"> 
			 <tr> 
				<th class="cellrowborder" valign="top" width="33.89830508474576%" id="d6937e327">Member 
				</th>
 
				<th class="cellrowborder" valign="top" width="66.10169491525423%" id="d6937e330">Description 
				</th>
 
			 </tr>
</thead>
 
		  <tbody> 
			 <tr> 
				<td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d6937e327 "><span class="keyword">Model Types</span> 
				</td>
 
				<td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d6937e330 "> 
				  <p>Classes 
					 <samp class="codeph"><samp class="codeph">spin_rw_mutex</samp></samp> and 
					 <samp class="codeph"><samp class="codeph">queuing_rw_mutex</samp></samp> model the
					 ReaderWriterMutex concept. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d6937e327 "><span class="keyword">ReaderWriterMutex()</span> 
				</td>
 
				<td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d6937e330 "> 
				  <p>Constructs unlocked 
					 <samp class="codeph">ReaderWriterMutex</samp>. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d6937e327 "><span class="keyword">~ReaderWriterMutex()</span> 
				</td>
 
				<td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d6937e330 "> 
				  <p>Destroys unlocked 
					 <samp class="codeph">ReaderWriterMutex</samp>. The effect of destroying a
					 locked 
					 <samp class="codeph">ReaderWriterMutex</samp> is undefined. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d6937e327 "><span class="keyword">ReaderWriterMutex::scoped_lock()</span> 
				</td>
 
				<td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d6937e330 "> 
				  <p>Constructs a 
					 <samp class="codeph">scoped_lock</samp> object that does not hold a lock
					 on any mutex. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d6937e327 "><span class="keyword"> ReaderWriterMutex::scoped_lock(
					 ReaderWriterMutex&amp; rw, bool write =true)</span> 
				</td>
 
				<td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d6937e330 "> 
				  <p>Constructs a 
					 <samp class="codeph">scoped_lock</samp> object that acquires a lock on
					 mutex 
					 <em>rw</em>. The lock is a writer lock if 
					 <samp class="codeph"><em>write</em></samp> is true; a reader lock otherwise.
					 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d6937e327 "><span class="keyword">ReaderWriterMutex::~scoped_lock()</span> 
				</td>
 
				<td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d6937e330 "> 
				  <p>If the object holds a lock on a 
					 <samp class="codeph">ReaderWriterMutex</samp>, releases the lock. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d6937e327 "><span class="keyword">void ReaderWriterMutex::
					 scoped_lock:: acquire( ReaderWriterMutex&amp; rw,&nbsp; bool write=true )</span> 
				</td>
 
				<td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d6937e330 "> 
				  <p>Acquires a lock on mutex 
					 <em>rw</em>. The lock is a writer lock if 
					 <samp class="codeph"><em>write</em></samp> is true; a reader lock otherwise.
					 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d6937e327 "><span class="keyword"> bool ReaderWriterMutex::
					 scoped_lock::try_acquire( ReaderWriterMutex&amp; rw, bool write=true
					 )</span> 
				</td>
 
				<td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d6937e330 "> 
				  <p>Attempts to acquire a lock on mutex 
					 <em>rw</em>. The lock is a writer lock if 
					 <samp class="codeph"><em>write</em></samp> is true; a reader lock otherwise.
					 
				  </p>
 
				  <p><strong>Returns</strong>: 
					 <samp class="codeph">true</samp> if the lock is acquired, 
					 <samp class="codeph">false</samp> otherwise. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d6937e327 "><span class="keyword"> void ReaderWriterMutex::
					 scoped_lock::release()</span> 
				</td>
 
				<td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d6937e330 "> 
				  <p>Releases lock. The effect is undefined if
					 no lock is held. 
				  </p>
 
				  <p><strong>Returns</strong>: 
					 <samp class="codeph">false</samp> if lock was released in favor of another
					 upgrade request and then reacquired; 
					 <samp class="codeph">true</samp> otherwise. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d6937e327 "><span class="keyword">bool ReaderWriterMutex::
					 scoped_lock::upgrade_to_writer()</span> 
				</td>
 
				<td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d6937e330 "> 
				  <p>Changes reader lock to a writer lock. The
					 effect is undefined if the object does not already hold a reader lock. 
				  </p>
 
				  <p><strong>Returns</strong>: 
					 <samp class="codeph">false</samp> if lock was released and reacquired; 
					 <samp class="codeph">true</samp> otherwise. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d6937e327 "><span class="keyword">bool ReaderWriterMutex::
					 scoped_lock::downgrade_to_reader()</span> 
				</td>
 
				<td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d6937e330 "> 
				  <p>Changes writer lock to a reader lock. The
					 effect is undefined if the object does not already hold a writer lock. 
				  </p>
 
				  <p><strong>Returns</strong>: 
					 <samp class="codeph">false</samp> if lock was released and reacquired; 
					 <samp class="codeph">true</samp> otherwise. 
				  </p>
 
				  <p>Intel's current implementations for 
					 <samp class="codeph">spin_rw_mutex</samp> and 
					 <samp class="codeph">queuing_rw_mutex</samp> always return 
					 <samp class="codeph">true</samp>. Different implementations might
					 sometimes return 
					 <samp class="codeph">false</samp>. 
				  </p>
 
				</td>
 
			 </tr>
 
		  </tbody>
 
		</table>
</div>
 
  </div>
 

<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="../../../reference/synchronization/mutexes.htm">Mutexes</a></div>
</div>
<div></div>

</body>
</html>
