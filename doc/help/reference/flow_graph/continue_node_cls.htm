
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0014)about:internet -->
<html xmlns:MSHelp="http://www.microsoft.com/MSHelp/" lang="en-us" xml:lang="en-us"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="DC.Type" content="reference">
<meta name="DC.Title" content="continue_node Template Class">
<meta name="DC.subject" content="continue_node Template Class">
<meta name="keywords" content="continue_node Template Class">
<meta name="DC.Relation" scheme="URI" content="../../reference/flow_graph.htm">
<meta name="DC.Relation" scheme="URI" content="make_edge_func.htm">
<meta name="DC.Relation" scheme="URI" content="remove_edge_func.htm">
<meta name="DC.Relation" scheme="URI" content="copy_body_func.htm">
<meta name="DC.Relation" scheme="URI" content="../task_scheduler/task_group_context.htm">
<meta name="DC.Relation" scheme="URI" content="../exceptions.htm">
<meta name="DC.Relation" scheme="URI" content="message_passing_protocol.htm">
<meta name="DC.Format" content="XHTML">
<meta name="DC.Identifier" content="continue_node_cls">
<meta name="DC.Language" content="en-US">
<link rel="stylesheet" type="text/css" href="../../intel_css_styles.css">
<title>continue_node Template Class</title>
</head>
<body id="continue_node_cls">
 <!-- ==============(Start:NavScript)================= -->
 <script src="../../NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
 <script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>
 <!-- ==============(End:NavScript)================= -->
<a name="continue_node_cls"><!-- --></a>

 
  <h1 class="topictitle1">continue_node Template Class</h1>
 
   
  <div> 
	 <div class="section"><h2 class="sectiontitle">Summary</h2> 
		 
		<p>A template class that is a 
		  <span class="keyword">graph_node</span>, 
		  <span class="keyword">continue_receiver</span> and a 
		  <span class="keyword">sender&lt;T&gt;</span>. It executes a specified body object
		  when triggered and broadcasts the generated value to all of its successors. 
		</p>
 
	 </div>
 
	 <div class="section"><h2 class="sectiontitle">Syntax</h2> 
		 
		<pre>template&lt; typename Output &gt; class continue_node;</pre> 
	 </div>
 
	 <div class="section"><h2 class="sectiontitle">Header</h2> 
		 
		<pre>#include "tbb/flow_graph.h"</pre> 
	 </div>
 
	 <div class="section"><h2 class="sectiontitle">Description</h2> 
		 
		<p>This type is used for nodes that wait for their predecessors to
		  complete before executing, but no explicit data is passed across the incoming
		  edges. The output of the node can be a 
		  <span class="keyword">continue_msg</span> or a value. 
		</p>
 
		<p>A 
		  <span class="keyword">continue_node</span> maintains an internal threshold, T,
		  and an internal counter, C. If a value for the number of predecessors is
		  provided at construction, then T is set to the provided value and C=0.
		  Otherwise, C=T=0. &nbsp; 
		</p>
 
		<p>At each call to method 
		  <span class="keyword">register_predecessor</span>, the threshold T is
		  incremented. At each call to method 
		  <span class="keyword">remove_predecessor</span>, the threshold T is decremented.
		  The functions 
		  <span class="keyword">make_edge</span> and 
		  <span class="keyword">remove_edge</span> appropriately call 
		  <span class="keyword">register_predecessor</span> and 
		  <span class="keyword">remove_predecessor</span> when edges are added to or
		  removed from a 
		  <span class="keyword">continue_node.</span> 
		</p>
 
		<p>At each call to method 
		  <span class="keyword">try_put</span>, C is incremented. If after the increment,
		  C&gt;=T, then C is reset to 0 and a task is enqueued to broadcast the result of
		  
		  <span class="keyword">body()</span> to all successors. The increment of C,
		  enqueueing of the task, and the resetting of C are all done atomically with
		  respect to the node. If after the increment, C&lt;T, no additional action is
		  taken. 
		</p>
 
		<p>The value generated by an execution of the body object is broadcast to
		  all successors. Rejection of messages by successors is handled using the
		  protocol in the Message Passing Protocol, see link below. 
		</p>
 
		<p>A 
		  <span class="keyword">continue_node</span> can serve as a terminal node in the
		  graph. The convention is to use an 
		  <span class="keyword">Output</span> of 
		  <span class="keyword">continue_msg</span> and attach no successor. 
		</p>
 
		<p>The Body concept for 
		  <span class="keyword">continue_node</span> is shown in below. 
		</p>
 
		
<div class="tablenoborder"><a name="tbl22"><!-- --></a><table cellpadding="4" summary="" id="tbl22" frame="border" border="1" cellspacing="0" rules="all"><caption><span class="tablecap">continue_node&lt;Output&gt; Body Concept</span></caption> 
		  <thead align="left"> 
			 <tr> 
				<th class="cellrowborder" align="center" valign="top" width="50%" id="d4246e139"> 
				  <p>Pseudo-Signature 
				  </p>
 
				</th>
 
				<th class="cellrowborder" align="center" valign="top" width="50%" id="d4246e145"> 
				  <p>Semantics 
				  </p>
 
				</th>
 
			 </tr>
</thead>
 
		  <tbody> 
			 <tr> 
				<td class="cellrowborder" valign="top" width="50%" headers="d4246e139 "> 
				  <p> 
					 <pre>B::B( const B&amp; )</pre> 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="50%" headers="d4246e145 "> 
				  <p>Copy constructor. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="50%" headers="d4246e139 "> 
				  <p> 
					 <pre>B::~B()</pre> 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="50%" headers="d4246e145 "> 
				  <p>Destructor. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="50%" headers="d4246e139 "> 
				  <p> 
					 <pre>void operator=( const B&amp; )</pre> 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="50%" headers="d4246e145 "> 
				  <p>Assignment. The return type 
					 <span class="keyword">void</span> in the pseudo-signature denotes that 
					 <span class="keyword">operator=</span> is not required to return a value.
					 The actual 
					 <span class="keyword">operator=</span> can return a value, which will be
					 ignored. 
				  </p>
 
				</td>
 
			 </tr>
 
			 <tr> 
				<td class="cellrowborder" valign="top" width="50%" headers="d4246e139 "> 
				  <p> 
					 <pre>Output B::operator()(const continue_msg &amp;v) const</pre> 
				  </p>
 
				</td>
 
				<td class="cellrowborder" valign="top" width="50%" headers="d4246e145 "> 
				  <p>Perform operation and return value of type Output. 
				  </p>
 
				</td>
 
			 </tr>
 
		  </tbody>
 
		</table>
</div>
 
		<div class="Note"><h3 class="NoteTipHead">
					Caution</h3> 
		  <p> The body object passed to a 
			 <span class="keyword">continue_node</span> is copied. Therefore updates to
			 member variables will not affect the original object used to construct the
			 node. If the state held within a body object must be inspected from outside of
			 the node, the 
			 <span class="keyword">copy_body</span> function can be used to obtain an
			 updated copy. 
		  </p>
 
		</div> 
		<div class="Note"><h3 class="NoteTipHead">
					Note</h3> 
		  <p> The body object may throw or cancel its enclosing graph. See
			 task_group_context and Exceptions sections for a description. 
		  </p>
 
		</div> 
		<div class="Note"><h3 class="NoteTipHead">
					Caution</h3> 
		  <p><span class="keyword">Output</span> must be copy-constructible and assignable.
			 
		  </p>
 
		</div> 
	 </div>
 
	 <div class="section"><h2 class="sectiontitle">Members</h2> 
		 
		<pre>namespace tbb {
namespace flow {
 
template&lt; typename Output &gt;
class continue_node :
  public graph_node, public continue_receiver,
  public sender&lt;Output&gt; {
public:
    template&lt;typename Body&gt;
    continue_node( graph &amp;g, Body body );
    template&lt;typename Body&gt;
    continue_node( graph &amp;g, int number_of_predecessors,
                     Body body );
    continue_node( const continue_node &amp;src );
 
    // continue_receiver
    typedef continue_msg input_type;
    typedef sender&lt;input_type&gt; predecessor_type;
    bool try_put( const input_type &amp;v );
    bool register_predecessor( predecessor_type &amp;p );
    bool remove_predecessor( predecessor_type &amp;p );
 
    // sender&lt;Output&gt;
    typedef Output output_type;
    typedef receiver&lt;output_type&gt; successor_type;
    bool register_successor( successor_type &amp;r );
    bool remove_successor( successor_type &amp;r );
    bool try_get( output_type &amp;v );
    bool try_reserve( output_type &amp;v );
    bool try_release( );
    bool try_consume( );
};
 
}
}</pre> 
		
<div class="tablenoborder"><table cellpadding="4" summary="" frame="border" border="1" cellspacing="0" rules="all"><span class="tabledesc">The following table provides additional information on the
			 members of this template class. 
		  </span><thead align="left"> 
				<tr> 
				  <th class="cellrowborder" valign="top" width="33.89830508474576%" id="d4246e285">Member 
				  </th>
 
				  <th class="cellrowborder" valign="top" width="66.10169491525423%" id="d4246e288">Description 
				  </th>
 
				</tr>
</thead>
 
			 <tbody> 
				<tr> 
				  <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d4246e285 "><span class="keyword">template&lt; typename Body&gt;
						continue_node( graph &amp;g, Body body )</span> 
				  </td>
 
				  <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d4246e288 "> 
					 <p>Constructs a 
						<span class="keyword">continue_node</span> that will invoke 
						<span class="keyword">body</span>. 
					 </p>
 
				  </td>
 
				</tr>
 
				<tr> 
				  <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d4246e285 "><span class="keyword">template&lt; typename Body&gt;
						continue_node( graph &amp;g, int number_of_predecessors, Body body )</span> 
				  </td>
 
				  <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d4246e288 "> 
					 <p>Constructs a 
						<span class="keyword">continue_node</span> that will invoke 
						<span class="keyword">body</span>. The threshold T is initialized to 
						<span class="keyword">number_of_predecessors</span>. 
					 </p>
 
				  </td>
 
				</tr>
 
				<tr> 
				  <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d4246e285 "><span class="keyword">continue_node( const continue_node
						&amp;src )</span> 
				  </td>
 
				  <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d4246e288 "> 
					 <p>Constructs a 
						<span class="keyword">continue_node</span> that has the same initial
						state that 
						<span class="keyword">src</span> had after its construction. It does
						not copy the current count of 
						<span class="keyword">try_puts</span> received, or the current known
						number of predecessors. The 
						<span class="keyword">continue_node</span> that is constructed will
						have a reference to the same 
						<span class="keyword">graph</span> object as 
						<span class="keyword">src</span>, have a copy of the initial 
						<span class="keyword">body</span> used by 
						<span class="keyword">src</span>, and only have a non-zero threshold if
						
						<span class="keyword">src</span> was constructed with a non-zero
						threshold. 
					 </p>
 
					 <div class="Note"><h3 class="NoteTipHead">
					Caution</h3> 
						<p> The new body object is copy constructed from a copy of
						  the original body provided to 
						  <span class="keyword">src</span> at its construction. Therefore
						  changes made to member variables in 
						  <span class="keyword">src</span>'s body after the construction of 
						  <span class="keyword">src</span> will not affect the body of the new 
						  <span class="keyword">continue_node</span>. 
						</p>
 
					 </div> 
				  </td>
 
				</tr>
 
				<tr> 
				  <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d4246e285 "><span class="keyword">bool try_put( const input_type
						&amp;v )</span> 
				  </td>
 
				  <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d4246e288 "> 
					 <p>Increments the count of 
						<span class="keyword">try_put</span> calls received. If the incremented
						count is equal to the number of known predecessors, a task is enqueued to
						execute the 
						<span class="keyword">body</span> and the internal count of 
						<span class="keyword">try_put</span> calls is reset to zero. This
						method performs as if the enqueueing of the body task and the updates to the
						internal count occur atomically. It does not wait for the execution of the body
						to complete. 
					 </p>
 
					 <p><strong>Returns</strong>: 
						<span class="keyword">true</span> 
					 </p>
 
				  </td>
 
				</tr>
 
				<tr> 
				  <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d4246e285 "><span class="keyword">bool register_predecessor(
						predecessor_type &amp;p )</span> 
				  </td>
 
				  <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d4246e288 "> 
					 <p>Increments the number of known predecessors. 
					 </p>
 
					 <p><strong>Returns</strong>: 
						<span class="keyword">true</span> 
					 </p>
 
				  </td>
 
				</tr>
 
				<tr> 
				  <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d4246e285 "><span class="keyword">bool remove_predecessor(
						predecessor_type &amp;p 
					 </span> 
				  </td>
 
				  <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d4246e288 "> 
					 <p>Decrements the number of known predecessors. 
					 </p>
 
					 <div class="Note"><h3 class="NoteTipHead">
					Caution</h3> 
						<p> The body is not called if the count of 
						  <span class="keyword">try_put</span> calls received becomes equal to
						  the number of known predecessors as a result of this call. That is, a call to 
						  <span class="keyword">remove_predecessor</span> will never invoke the
						  body. 
						</p>
 
					 </div> 
				  </td>
 
				</tr>
 
				<tr> 
				  <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d4246e285 "><span class="keyword">bool register_successor(
						successor_type &amp;r )</span> 
				  </td>
 
				  <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d4246e288 "> 
					 <p>Adds 
						<span class="keyword">r</span> to the set of successors. 
					 </p>
 
					 <p><strong>Returns</strong>: 
						<span class="keyword">true</span> 
					 </p>
 
				  </td>
 
				</tr>
 
				<tr> 
				  <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d4246e285 "><span class="keyword">bool remove_successor(
						successor_type &amp;r )</span> 
				  </td>
 
				  <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d4246e288 "> 
					 <p>Removes 
						<span class="keyword">r</span> from the set of successors. 
					 </p>
 
					 <p><strong>Returns</strong>: 
						<span class="keyword">true</span> 
					 </p>
 
				  </td>
 
				</tr>
 
				<tr> 
				  <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d4246e285 "><span class="keyword">bool try_get( output_type &amp;v
						)</span> 
				  </td>
 
				  <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d4246e288 "> 
					 <p>The 
						<span class="keyword">continue_node</span> does not contain buffering.
						Therefore it always rejects 
						<span class="keyword">try_get</span> calls. 
					 </p>
 
					 <p><strong>Returns</strong>: 
						<span class="keyword">false</span> 
					 </p>
 
				  </td>
 
				</tr>
 
				<tr> 
				  <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d4246e285 "><span class="keyword">bool try_reserve( output_type
						&amp;v )</span> 
				  </td>
 
				  <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d4246e288 "> 
					 <p>The 
						<span class="keyword">continue_node</span> does not contain buffering.
						Therefore it cannot be reserved. 
					 </p>
 
					 <p><strong>Returns</strong>: 
						<span class="keyword">false</span> 
					 </p>
 
				  </td>
 
				</tr>
 
				<tr> 
				  <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d4246e285 "><span class="keyword">bool try_release( )</span> 
				  </td>
 
				  <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d4246e288 "> 
					 <p>The 
						<span class="keyword">continue_node</span> does not contain buffering.
						Therefore it cannot be reserved. 
					 </p>
 
					 <p><strong>Returns</strong>: 
						<span class="keyword">false</span> 
					 </p>
 
				  </td>
 
				</tr>
 
				<tr> 
				  <td class="cellrowborder" valign="top" width="33.89830508474576%" headers="d4246e285 "><span class="keyword">bool try_consume( )</span> 
				  </td>
 
				  <td class="cellrowborder" valign="top" width="66.10169491525423%" headers="d4246e288 "> 
					 <p>The 
						<span class="keyword">continue_node</span> does not contain buffering.
						Therefore it cannot be reserved. 
					 </p>
 
					 <p><strong>Returns</strong>: 
						<span class="keyword">false</span> 
					 </p>
 
				  </td>
 
				</tr>
 
			 </tbody>
 
		  </table>
</div>
 
	 </div>
 
  </div>
 
  
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="../../reference/flow_graph.htm">Flow Graph</a></div>
</div>
<div class="See Also">
<h2>See Also</h2>
<div class="linklist">
<div><a href="make_edge_func.htm">make_edge Template Function 
		  </a></div>
<div><a href="remove_edge_func.htm">remove_edge Template Function 
		  </a></div>
<div><a href="copy_body_func.htm">copy_body Template Function 
		  </a></div>
<div><a href="../task_scheduler/task_group_context.htm">task_group_context 
		  </a></div>
<div><a href="../exceptions.htm">Exceptions 
		  </a></div>
<div><a href="message_passing_protocol.htm">Message Passing Protocol 
		  </a></div></div>
</div> 

</body>
</html>
