<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>tbb Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>tbb Namespace Reference</h1>
<p>The namespace <a class="el" href="a00236.html" title="The namespace tbb contains all components of the library.">tbb</a> contains all components of the library.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html">aligned_space</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block of space aligned sufficiently to construct an array T with N elements.  <a href="a00008.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html">atomic</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html">atomic&lt; void * &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for <a class="el" href="a00012.html" title="Specialization for atomic&lt;void*&gt;, for sake of not allowing arithmetic or operator-&gt;...">atomic&lt;void*&gt;</a>, for sake of not allowing arithmetic or operator-&gt;.  <a href="a00012.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00024.html">blocked_range</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A range over which to iterate.  <a href="a00024.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00025.html">blocked_range2d</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A 2-dimensional range that models the Range concept.  <a href="a00025.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html">blocked_range3d</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A 3-dimensional range that models the Range concept.  <a href="a00026.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00031.html">cache_aligned_allocator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00032.html">cache_aligned_allocator&lt; void &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00032.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00034.html">combinable</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread-local storage with optional reduction.  <a href="a00034.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00160.html">tbb_hash_compare</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">hash_compare that is default argument for concurrent_hash_map  <a href="a00160.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html">concurrent_bounded_queue</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A high-performance thread-safe blocking concurrent bounded queue.  <a href="a00035.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html">concurrent_vector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html">mutex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper around the platform's native reader-writer lock.  <a href="a00090.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html">null_mutex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="a00090.html" title="Wrapper around the platform&#39;s native reader-writer lock.">mutex</a> which does nothing.  <a href="a00093.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00094.html">null_rw_mutex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A rw <a class="el" href="a00090.html" title="Wrapper around the platform&#39;s native reader-writer lock.">mutex</a> which does nothing.  <a href="a00094.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00097.html">parallel_do_feeder</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00149.html">task_group_context</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to form groups of tasks.  <a href="a00149.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00101.html">pre_scan_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to indicate that the initial scan is being performed.  <a href="a00101.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00058.html">final_scan_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to indicate that the final scan is being performed.  <a href="a00058.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html">parallel_while</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00136.html">simple_partitioner</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A simple partitioner.  <a href="a00136.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html">auto_partitioner</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An auto partitioner.  <a href="a00019.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html">affinity_partitioner</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An affinity partitioner.  <a href="a00003.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00056.html">filter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00161.html">thread_bound_filter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A stage in a <a class="el" href="a00100.html" title="A processing pipeline that applies filters to items.">pipeline</a> served by a user thread.  <a href="a00161.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00100.html">pipeline</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A processing <a class="el" href="a00100.html" title="A processing pipeline that applies filters to items.">pipeline</a> that applies filters to items.  <a href="a00100.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00104.html">queuing_mutex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queuing <a class="el" href="a00090.html" title="Wrapper around the platform&#39;s native reader-writer lock.">mutex</a> with local-only spinning.  <a href="a00104.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00105.html">queuing_rw_mutex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queuing reader-writer <a class="el" href="a00090.html" title="Wrapper around the platform&#39;s native reader-writer lock.">mutex</a> with local-only spinning.  <a href="a00105.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00118.html">recursive_mutex</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00121.html">scalable_allocator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5.  <a href="a00121.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html">scalable_allocator&lt; void &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00122.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html">spin_mutex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A lock that occupies a single byte.  <a href="a00138.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00139.html">spin_rw_mutex_v3</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast, unfair, spinning reader-writer lock with backoff and writer-preference.  <a href="a00139.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html">task</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for user-defined tasks.  <a href="a00144.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html">empty_task</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> that does nothing. Useful for synchronization.  <a href="a00054.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html">task_list</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A list of children.  <a href="a00152.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00150.html">task_handle</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00147.html">task_group</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00143.html">structured_task_group</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00153.html">task_scheduler_init</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html">tbb_allocator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00157.html">tbb_allocator&lt; void &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00157.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html">zero_allocator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5.  <a href="a00174.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00175.html">zero_allocator&lt; void, Allocator &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00175.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html">bad_last_alloc</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception for concurrent containers.  <a href="a00020.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html">improper_lock</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception for PPL locks.  <a href="a00068.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00170.html">user_abort</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception for user-initiated abort.  <a href="a00170.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html">missing_wait</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception for missing wait on <a class="el" href="a00143.html">structured_task_group</a>.  <a href="a00085.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html">invalid_multiple_scheduling</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception for repeated scheduling of the same <a class="el" href="a00150.html">task_handle</a>.  <a href="a00070.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00158.html">tbb_exception</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface to be implemented by all exceptions TBB recognizes and propagates across the threads.  <a href="a00158.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00033.html">captured_exception</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is used by TBB to propagate information about unhandled exceptions into the root thread.  <a href="a00033.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html">movable_exception</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Template that can be used to implement exception that transfers arbitrary ExceptionData to the root thread.  <a href="a00086.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00140.html">split</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dummy type that distinguishes splitting constructor from copy constructor.  <a href="a00140.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00162.html">tick_count</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Absolute timestamp.  <a href="a00162.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a889d8f126388fdc24c597d195a4d7028"></a><!-- doxytag: member="tbb::critical_section" ref="a889d8f126388fdc24c597d195a4d7028" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="a00053.html">internal::critical_section_v4</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>critical_section</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cc3d02744cab8ac389919806d47e417"></a><!-- doxytag: member="tbb::spin_rw_mutex" ref="a6cc3d02744cab8ac389919806d47e417" args="" -->
typedef <a class="el" href="a00139.html">spin_rw_mutex_v3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>spin_rw_mutex</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a268320974a3357e9609a2f98be5090"></a><!-- doxytag: member="tbb::stack_size_type" ref="a1a268320974a3357e9609a2f98be5090" args="" -->
typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>stack_size_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af58de4ab3200dd2bd621f052c6f677e4"></a><!-- doxytag: member="tbb::task_scheduler_observer" ref="af58de4ab3200dd2bd621f052c6f677e4" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="a00155.html">tbb::internal::task_scheduler_observer_v3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>task_scheduler_observer</b></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00236.html#adb86d08473679d6fe0eabcdc766ffe3a">memory_semantics</a> { <a class="el" href="a00236.html#adb86d08473679d6fe0eabcdc766ffe3aa6a315190cf4509ec388ecb423432f36a">full_fence</a>, 
<a class="el" href="a00236.html#adb86d08473679d6fe0eabcdc766ffe3aaa92646b4dc7618530d3a9f51dd10a418">acquire</a>, 
<a class="el" href="a00236.html#adb86d08473679d6fe0eabcdc766ffe3aa412563418e657114a102db610f726632">release</a>, 
<a class="el" href="a00236.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Specifies memory semantics. </p>
 <a href="a00236.html#adb86d08473679d6fe0eabcdc766ffe3a">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00236.html#ac5bcb6154c8307fa9f97806afddf2288">ets_key_usage_type</a> { <b>ets_key_per_instance</b>, 
<b>ets_no_key</b>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>enum for selecting between single key and key-per-instance versions </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>priority_t</b> { <b>priority_normal</b> =  internal::priority_stride_v4 * 2, 
<b>priority_low</b> =  priority_normal - internal::priority_stride_v4, 
<b>priority_high</b> =  priority_normal + internal::priority_stride_v4
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>task_group_status</b> { <b>not_complete</b>, 
<b>complete</b>, 
<b>canceled</b>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fefe7ed201b920d3fd6c390849c1ccf"></a><!-- doxytag: member="tbb::__TBB_DECL_ATOMIC" ref="a5fefe7ed201b920d3fd6c390849c1ccf" args="(__TBB_LONG_LONG) __TBB_DECL_ATOMIC(unsigned __TBB_LONG_LONG) __TBB_DECL_ATOMIC(long) __TBB_DECL_ATOMIC(unsigned long) __TBB_DECL_ATOMIC_ALT(unsigned" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>__TBB_DECL_ATOMIC</b> (__TBB_LONG_LONG) __TBB_DECL_ATOMIC(unsigned __TBB_LONG_LONG) __TBB_DECL_ATOMIC(long) __TBB_DECL_ATOMIC(unsigned long) __TBB_DECL_ATOMIC_ALT(unsigned</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59425abdcb421136e9f5954cfb975e5f"></a><!-- doxytag: member="tbb::__TBB_DECL_ATOMIC_ALT" ref="a59425abdcb421136e9f5954cfb975e5f" args="(int, ptrdiff_t) __TBB_DECL_ATOMIC(unsigned) __TBB_DECL_ATOMIC(int) __TBB_DECL_ATOMIC(unsigned short) __TBB_DECL_ATOMIC(short) __TBB_DECL_ATOMIC(char) __TBB_DECL_ATOMIC(signed char) __TBB_DECL_ATOMIC(unsigned char) __TBB_DECL_ATOMIC(wchar_t) template&lt; typename T &gt; struct atomic&lt; T * &gt;" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00236.html#a59425abdcb421136e9f5954cfb975e5f">__TBB_DECL_ATOMIC_ALT</a> (int, ptrdiff_t) __TBB_DECL_ATOMIC(unsigned) __TBB_DECL_ATOMIC(int) __TBB_DECL_ATOMIC(unsigned short) __TBB_DECL_ATOMIC(short) __TBB_DECL_ATOMIC(char) __TBB_DECL_ATOMIC(signed char) __TBB_DECL_ATOMIC(unsigned char) __TBB_DECL_ATOMIC(wchar_t) template&lt; typename T &gt; struct <a class="el" href="a00011.html">atomic</a>&lt; T * &gt;</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for atomic&lt;T*&gt; with arithmetic and operator-&gt;. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa8e5f924093138307aa7c4d6285cdea5"></a><!-- doxytag: member="tbb::load" ref="aa8e5f924093138307aa7c4d6285cdea5" args="(const atomic&lt; T &gt; &amp;a)" -->
template&lt;memory_semantics M, typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>load</b> (const <a class="el" href="a00011.html">atomic</a>&lt; T &gt; &amp;a)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a7aeede60c40d5a4edad3553252b29694"></a><!-- doxytag: member="tbb::store" ref="a7aeede60c40d5a4edad3553252b29694" args="(atomic&lt; T &gt; &amp;a, T value)" -->
template&lt;memory_semantics M, typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>store</b> (<a class="el" href="a00011.html">atomic</a>&lt; T &gt; &amp;a, T value)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a1b2276ee833170891664f250651ff3ee"></a><!-- doxytag: member="tbb::operator==" ref="a1b2276ee833170891664f250651ff3ee" args="(const cache_aligned_allocator&lt; T &gt; &amp;, const cache_aligned_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T , typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00031.html">cache_aligned_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00031.html">cache_aligned_allocator</a>&lt; U &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ac9a723aec9ae9162676dd850b2d31d53"></a><!-- doxytag: member="tbb::operator!=" ref="ac9a723aec9ae9162676dd850b2d31d53" args="(const cache_aligned_allocator&lt; T &gt; &amp;, const cache_aligned_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T , typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00031.html">cache_aligned_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00031.html">cache_aligned_allocator</a>&lt; U &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8b5f60bc21f5db841e4b4cfc20c07a45"></a><!-- doxytag: member="tbb::operator==" ref="a8b5f60bc21f5db841e4b4cfc20c07a45" args="(const concurrent_hash_map&lt; Key, T, HashCompare, A1 &gt; &amp;a, const concurrent_hash_map&lt; Key, T, HashCompare, A2 &gt; &amp;b)" -->
template&lt;typename Key , typename T , typename HashCompare , typename A1 , typename A2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const concurrent_hash_map&lt; Key, T, HashCompare, A1 &gt; &amp;a, const concurrent_hash_map&lt; Key, T, HashCompare, A2 &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a15c8ae40cf454f1487b1a202cbad7369"></a><!-- doxytag: member="tbb::operator!=" ref="a15c8ae40cf454f1487b1a202cbad7369" args="(const concurrent_hash_map&lt; Key, T, HashCompare, A1 &gt; &amp;a, const concurrent_hash_map&lt; Key, T, HashCompare, A2 &gt; &amp;b)" -->
template&lt;typename Key , typename T , typename HashCompare , typename A1 , typename A2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const concurrent_hash_map&lt; Key, T, HashCompare, A1 &gt; &amp;a, const concurrent_hash_map&lt; Key, T, HashCompare, A2 &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a992318870d30e96f75404d9c8cc65c8e"></a><!-- doxytag: member="tbb::swap" ref="a992318870d30e96f75404d9c8cc65c8e" args="(concurrent_hash_map&lt; Key, T, HashCompare, A &gt; &amp;a, concurrent_hash_map&lt; Key, T, HashCompare, A &gt; &amp;b)" -->
template&lt;typename Key , typename T , typename HashCompare , typename A &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (concurrent_hash_map&lt; Key, T, HashCompare, A &gt; &amp;a, concurrent_hash_map&lt; Key, T, HashCompare, A &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af6460b8dd7db1ae82fce7e0dd32199f1"></a><!-- doxytag: member="tbb::operator==" ref="af6460b8dd7db1ae82fce7e0dd32199f1" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T , class A1 , class A2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00047.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00047.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a30f917166e03c6ce6a7de793f98c9d30"></a><!-- doxytag: member="tbb::operator!=" ref="a30f917166e03c6ce6a7de793f98c9d30" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T , class A1 , class A2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00047.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00047.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a1b009d587157273622139bc6b03f1771"></a><!-- doxytag: member="tbb::operator&lt;" ref="a1b009d587157273622139bc6b03f1771" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T , class A1 , class A2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="a00047.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00047.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa277363fadae7c6e03333f4da0f17ad0"></a><!-- doxytag: member="tbb::operator&gt;" ref="aa277363fadae7c6e03333f4da0f17ad0" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T , class A1 , class A2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="a00047.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00047.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a273dfe160cca44b7b8975b8d78d7268e"></a><!-- doxytag: member="tbb::operator&lt;=" ref="a273dfe160cca44b7b8975b8d78d7268e" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T , class A1 , class A2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="a00047.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00047.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a0b11711c75d79aba35fe67435271fbb6"></a><!-- doxytag: member="tbb::operator&gt;=" ref="a0b11711c75d79aba35fe67435271fbb6" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T , class A1 , class A2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="a00047.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00047.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="afe4c5745b2e460de448602a95f7ad4c0"></a><!-- doxytag: member="tbb::swap" ref="afe4c5745b2e460de448602a95f7ad4c0" args="(concurrent_vector&lt; T, A &gt; &amp;a, concurrent_vector&lt; T, A &gt; &amp;b)" -->
template&lt;typename T , class A &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="a00047.html">concurrent_vector</a>&lt; T, A &gt; &amp;a, <a class="el" href="a00047.html">concurrent_vector</a>&lt; T, A &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a86ff5d4e516a1b8d4857719a8b30c3b7"></a><!-- doxytag: member="tbb::operator==" ref="a86ff5d4e516a1b8d4857719a8b30c3b7" args="(const scalable_allocator&lt; T &gt; &amp;, const scalable_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T , typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00121.html">scalable_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00121.html">scalable_allocator</a>&lt; U &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a9738de781dba5c37e5489657aac3a9c6"></a><!-- doxytag: member="tbb::operator!=" ref="a9738de781dba5c37e5489657aac3a9c6" args="(const scalable_allocator&lt; T &gt; &amp;, const scalable_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T , typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00121.html">scalable_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00121.html">scalable_allocator</a>&lt; U &gt; &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaef1698b222ba9312ab24dcdcd98bbd8"></a><!-- doxytag: member="tbb::is_current_task_group_canceling" ref="aaef1698b222ba9312ab24dcdcd98bbd8" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>is_current_task_group_canceling</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a96f84056d7899a90d43b02871d9268c1"></a><!-- doxytag: member="tbb::make_task" ref="a96f84056d7899a90d43b02871d9268c1" args="(const F &amp;f)" -->
template&lt;class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00150.html">task_handle</a>&lt; F &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>make_task</b> (const F &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af51bacdb4a1e2ab08c55e64bb7bac1e6"></a><!-- doxytag: member="tbb::operator==" ref="af51bacdb4a1e2ab08c55e64bb7bac1e6" args="(const tbb_allocator&lt; T &gt; &amp;, const tbb_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T , typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00156.html">tbb_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00156.html">tbb_allocator</a>&lt; U &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a068cf2a2175e43e8c6b30d8b9965481a"></a><!-- doxytag: member="tbb::operator!=" ref="a068cf2a2175e43e8c6b30d8b9965481a" args="(const tbb_allocator&lt; T &gt; &amp;, const tbb_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T , typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00156.html">tbb_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00156.html">tbb_allocator</a>&lt; U &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a28401e60d1f2989fb39d3c24f22165a1"></a><!-- doxytag: member="tbb::operator==" ref="a28401e60d1f2989fb39d3c24f22165a1" args="(const zero_allocator&lt; T1, B1 &gt; &amp;a, const zero_allocator&lt; T2, B2 &gt; &amp;b)" -->
template&lt;typename T1 , template&lt; typename X1 &gt; class B1, typename T2 , template&lt; typename X2 &gt; class B2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00174.html">zero_allocator</a>&lt; T1, B1 &gt; &amp;a, const <a class="el" href="a00174.html">zero_allocator</a>&lt; T2, B2 &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3b992dd773b8ae023abc4fe55948202a"></a><!-- doxytag: member="tbb::operator!=" ref="a3b992dd773b8ae023abc4fe55948202a" args="(const zero_allocator&lt; T1, B1 &gt; &amp;a, const zero_allocator&lt; T2, B2 &gt; &amp;b)" -->
template&lt;typename T1 , template&lt; typename X1 &gt; class B1, typename T2 , template&lt; typename X2 &gt; class B2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00174.html">zero_allocator</a>&lt; T1, B1 &gt; &amp;a, const <a class="el" href="a00174.html">zero_allocator</a>&lt; T2, B2 &gt; &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33e73b97b02726c692bd8d9da8e3fb1b"></a><!-- doxytag: member="tbb::atomic_fence" ref="a33e73b97b02726c692bd8d9da8e3fb1b" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00236.html#a33e73b97b02726c692bd8d9da8e3fb1b">atomic_fence</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sequentially consistent full memory fence. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00236.html#ade8a8bc300d5ef09d38cbfb8baff5cd2">TBB_runtime_interface_version</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function returns the interface version of the TBB shared library being used.  <a href="#ade8a8bc300d5ef09d38cbfb8baff5cd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa037c1f149250d61cd2fad4541a5e6cb"></a><!-- doxytag: member="tbb::operator&#45;" ref="aa037c1f149250d61cd2fad4541a5e6cb" args="(const tick_count &amp;t1, const tick_count &amp;t0)" -->
<a class="el" href="a00069.html">tick_count::interval_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="a00162.html">tick_count</a> &amp;t1, const <a class="el" href="a00162.html">tick_count</a> &amp;t0)</td></tr>
<tr><td colspan="2"><div class="groupHeader">parallel_do</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp751e5e5b1749802e9339f8ae6e071bc7"></a> See also requirements on <a class="el" href="parallel_do_body_req.html">parallel_do Body</a>. </p>
<br/><br/></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga2bff63883d023abb09d236c69a177cb0">parallel_do</a> (Iterator first, Iterator last, const Body &amp;body)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over a range, with optional addition of more work.  <a href="a00249.html#ga2bff63883d023abb09d236c69a177cb0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gaf02bc6290b7866d4ad1de75bb07f762b">parallel_do</a> (Iterator first, Iterator last, const Body &amp;body, <a class="el" href="a00149.html">task_group_context</a> &amp;context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over a range, with optional addition of more work and user-supplied context.  <a href="a00249.html#gaf02bc6290b7866d4ad1de75bb07f762b"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">parallel_for</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp020f371880777e82219a69f8a512e874"></a> See also requirements on <a class="el" href="range_req.html">Range</a> and <a class="el" href="parallel_for_body_req.html">parallel_for Body</a>. </p>
<br/><br/></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga809af9d6d765ac0c7b4149d1b364479f">parallel_for</a> (const Range &amp;range, const Body &amp;body)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with default partitioner.  <a href="a00249.html#ga809af9d6d765ac0c7b4149d1b364479f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gaf450e3d3a604d1618110072dfb1e0cbe">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00136.html">simple_partitioner</a> &amp;partitioner)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with simple partitioner.  <a href="a00249.html#gaf450e3d3a604d1618110072dfb1e0cbe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga27e05270168bd7bf241eca1e98ed57ef">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00019.html">auto_partitioner</a> &amp;partitioner)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00019.html" title="An auto partitioner.">auto_partitioner</a>.  <a href="a00249.html#ga27e05270168bd7bf241eca1e98ed57ef"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga157a7f91932c506c50181e2133353639">parallel_for</a> (const Range &amp;range, const Body &amp;body, <a class="el" href="a00003.html">affinity_partitioner</a> &amp;partitioner)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00003.html" title="An affinity partitioner.">affinity_partitioner</a>.  <a href="a00249.html#ga157a7f91932c506c50181e2133353639"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga4ba06c6b19f5530ad604b65f4137c97f">parallel_for</a> (const Range &amp;range, const Body &amp;body, <a class="el" href="a00149.html">task_group_context</a> &amp;context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with default partitioner and user-supplied context.  <a href="a00249.html#ga4ba06c6b19f5530ad604b65f4137c97f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga975260c595b505d13b442897f044c124">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00136.html">simple_partitioner</a> &amp;partitioner, <a class="el" href="a00149.html">task_group_context</a> &amp;context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with simple partitioner and user-supplied context.  <a href="a00249.html#ga975260c595b505d13b442897f044c124"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gaecb7deb88c8ca869cd3245800435e68d">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00019.html">auto_partitioner</a> &amp;partitioner, <a class="el" href="a00149.html">task_group_context</a> &amp;context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00019.html" title="An auto partitioner.">auto_partitioner</a> and user-supplied context.  <a href="a00249.html#gaecb7deb88c8ca869cd3245800435e68d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gaaccc2568e8f502751a6de09da6b144ba">parallel_for</a> (const Range &amp;range, const Body &amp;body, <a class="el" href="a00003.html">affinity_partitioner</a> &amp;partitioner, <a class="el" href="a00149.html">task_group_context</a> &amp;context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00003.html" title="An affinity partitioner.">affinity_partitioner</a> and user-supplied context.  <a href="a00249.html#gaaccc2568e8f502751a6de09da6b144ba"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">parallel_for_each</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp7ce4a4ed4c691c461716d1501614cab4"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename Function &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga9465bfb7d751f5b167f446d6933934b9">parallel_for_each</a> (InputIterator first, InputIterator last, const Function &amp;f, <a class="el" href="a00149.html">task_group_context</a> &amp;context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls function f for all items from [first, last) interval using user-supplied context.  <a href="a00249.html#ga9465bfb7d751f5b167f446d6933934b9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga92a4c382c663a1b3120d6f434ba5e36e"></a><!-- doxytag: member="tbb::parallel_for_each" ref="ga92a4c382c663a1b3120d6f434ba5e36e" args="(InputIterator first, InputIterator last, const Function &amp;f)" -->
template&lt;typename InputIterator , typename Function &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga92a4c382c663a1b3120d6f434ba5e36e">parallel_for_each</a> (InputIterator first, InputIterator last, const Function &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses default context. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">parallel_invoke</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp5e4bb2aa1ed8711c184ce6fed2a59332"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename F0 , typename F1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga0ca48b0a7be3615b3b9f538112616076">parallel_invoke</a> (const F0 &amp;f0, const F1 &amp;f1, <a class="el" href="a00149.html">tbb::task_group_context</a> &amp;context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes a list of tasks in parallel and waits for all tasks to complete.  <a href="a00249.html#ga0ca48b0a7be3615b3b9f538112616076"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1b257aa33f7d6c79dc4c242b7b481e70"></a><!-- doxytag: member="tbb::parallel_invoke" ref="ga1b257aa33f7d6c79dc4c242b7b481e70" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, tbb::task_group_context &amp;context)" -->
template&lt;typename F0 , typename F1 , typename F2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, <a class="el" href="a00149.html">tbb::task_group_context</a> &amp;context)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga14bb2af2f85c990286b64da6087ba19d"></a><!-- doxytag: member="tbb::parallel_invoke" ref="ga14bb2af2f85c990286b64da6087ba19d" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, tbb::task_group_context &amp;context)" -->
template&lt;typename F0 , typename F1 , typename F2 , typename F3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, <a class="el" href="a00149.html">tbb::task_group_context</a> &amp;context)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga03e53f2d34abf02771b6cd92de56258b"></a><!-- doxytag: member="tbb::parallel_invoke" ref="ga03e53f2d34abf02771b6cd92de56258b" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, tbb::task_group_context &amp;context)" -->
template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, <a class="el" href="a00149.html">tbb::task_group_context</a> &amp;context)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gab5b0744238c029b76eebbd48dbd71867"></a><!-- doxytag: member="tbb::parallel_invoke" ref="gab5b0744238c029b76eebbd48dbd71867" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, tbb::task_group_context &amp;context)" -->
template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 , typename F5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, <a class="el" href="a00149.html">tbb::task_group_context</a> &amp;context)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa2b2e5546e59df7497d3fd8bb42a4f9b"></a><!-- doxytag: member="tbb::parallel_invoke" ref="gaa2b2e5546e59df7497d3fd8bb42a4f9b" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, tbb::task_group_context &amp;context)" -->
template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 , typename F5 , typename F6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, <a class="el" href="a00149.html">tbb::task_group_context</a> &amp;context)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga3a207900c8b529b399322065e590402c"></a><!-- doxytag: member="tbb::parallel_invoke" ref="ga3a207900c8b529b399322065e590402c" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, tbb::task_group_context &amp;context)" -->
template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 , typename F5 , typename F6 , typename F7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, <a class="el" href="a00149.html">tbb::task_group_context</a> &amp;context)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gadbc0ae6c5e0558f383c7917dbbac4c44"></a><!-- doxytag: member="tbb::parallel_invoke" ref="gadbc0ae6c5e0558f383c7917dbbac4c44" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8, tbb::task_group_context &amp;context)" -->
template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 , typename F5 , typename F6 , typename F7 , typename F8 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8, <a class="el" href="a00149.html">tbb::task_group_context</a> &amp;context)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga12f9ad0999e830eac907ab36abd26a16"></a><!-- doxytag: member="tbb::parallel_invoke" ref="ga12f9ad0999e830eac907ab36abd26a16" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8, const F9 &amp;f9, tbb::task_group_context &amp;context)" -->
template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 , typename F5 , typename F6 , typename F7 , typename F8 , typename F9 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8, const F9 &amp;f9, <a class="el" href="a00149.html">tbb::task_group_context</a> &amp;context)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga15041e61e27d15ca4d7d00daf8e41d69"></a><!-- doxytag: member="tbb::parallel_invoke" ref="ga15041e61e27d15ca4d7d00daf8e41d69" args="(const F0 &amp;f0, const F1 &amp;f1)" -->
template&lt;typename F0 , typename F1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gab0906227fac7d485df19eeed7a418259"></a><!-- doxytag: member="tbb::parallel_invoke" ref="gab0906227fac7d485df19eeed7a418259" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2)" -->
template&lt;typename F0 , typename F1 , typename F2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga59d1e4d81d98310b37b8e7056af4a6d4"></a><!-- doxytag: member="tbb::parallel_invoke" ref="ga59d1e4d81d98310b37b8e7056af4a6d4" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3)" -->
template&lt;typename F0 , typename F1 , typename F2 , typename F3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga927a13f932a2c3a460268e1ac474c15b"></a><!-- doxytag: member="tbb::parallel_invoke" ref="ga927a13f932a2c3a460268e1ac474c15b" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4)" -->
template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa8ec54b7f5847024114ff84adbe538c0"></a><!-- doxytag: member="tbb::parallel_invoke" ref="gaa8ec54b7f5847024114ff84adbe538c0" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5)" -->
template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 , typename F5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga34ff3436fbb03e07548b2464c927818d"></a><!-- doxytag: member="tbb::parallel_invoke" ref="ga34ff3436fbb03e07548b2464c927818d" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6)" -->
template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 , typename F5 , typename F6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gae54b6f2a7cf110bd70515e33da26a5be"></a><!-- doxytag: member="tbb::parallel_invoke" ref="gae54b6f2a7cf110bd70515e33da26a5be" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7)" -->
template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 , typename F5 , typename F6 , typename F7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga21a3d80287bb4662512e7dee88ec91bb"></a><!-- doxytag: member="tbb::parallel_invoke" ref="ga21a3d80287bb4662512e7dee88ec91bb" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8)" -->
template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 , typename F5 , typename F6 , typename F7 , typename F8 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga24440d67c8e12ca59f53a5913439c902"></a><!-- doxytag: member="tbb::parallel_invoke" ref="ga24440d67c8e12ca59f53a5913439c902" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8, const F9 &amp;f9)" -->
template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 , typename F5 , typename F6 , typename F7 , typename F8 , typename F9 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8, const F9 &amp;f9)</td></tr>
<tr><td colspan="2"><div class="groupHeader">parallel_reduce</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp949e4773fffd16cb2d32f76af48627d2"></a> See also requirements on <a class="el" href="range_req.html">Range</a> and <a class="el" href="parallel_reduce_body_req.html">parallel_reduce Body</a>. </p>
<br/><br/></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga952536d8b82089d2780e552cc42081c6">parallel_reduce</a> (const Range &amp;range, Body &amp;body)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and default partitioner.  <a href="a00249.html#ga952536d8b82089d2780e552cc42081c6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gaaf173f545cc4c5c635d48ca455cf8aa7">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00136.html">simple_partitioner</a> &amp;partitioner)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00136.html" title="A simple partitioner.">simple_partitioner</a>.  <a href="a00249.html#gaaf173f545cc4c5c635d48ca455cf8aa7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga1605f10c9af1e0dc4d51d17d6e6b1446">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00019.html">auto_partitioner</a> &amp;partitioner)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00019.html" title="An auto partitioner.">auto_partitioner</a>.  <a href="a00249.html#ga1605f10c9af1e0dc4d51d17d6e6b1446"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga22a6bd324785146fa9c8fa343c975194">parallel_reduce</a> (const Range &amp;range, Body &amp;body, <a class="el" href="a00003.html">affinity_partitioner</a> &amp;partitioner)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00003.html" title="An affinity partitioner.">affinity_partitioner</a>.  <a href="a00249.html#ga22a6bd324785146fa9c8fa343c975194"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga35f71209bf3addde62379b4a7976b273">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00136.html">simple_partitioner</a> &amp;partitioner, <a class="el" href="a00149.html">task_group_context</a> &amp;context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, simple partitioner and user-supplied context.  <a href="a00249.html#ga35f71209bf3addde62379b4a7976b273"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga93b01fd8e3a77c1b066c4ad1cae7ae2d">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00019.html">auto_partitioner</a> &amp;partitioner, <a class="el" href="a00149.html">task_group_context</a> &amp;context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00019.html" title="An auto partitioner.">auto_partitioner</a> and user-supplied context.  <a href="a00249.html#ga93b01fd8e3a77c1b066c4ad1cae7ae2d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga42193506a329a605af9df6bc4dddc546">parallel_reduce</a> (const Range &amp;range, Body &amp;body, <a class="el" href="a00003.html">affinity_partitioner</a> &amp;partitioner, <a class="el" href="a00149.html">task_group_context</a> &amp;context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00003.html" title="An affinity partitioner.">affinity_partitioner</a> and user-supplied context.  <a href="a00249.html#ga42193506a329a605af9df6bc4dddc546"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gaa9322987a244031f98b0cd3b8a6e11e5">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and default partitioner.  <a href="a00249.html#gaa9322987a244031f98b0cd3b8a6e11e5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gabd49b7d7f63dc92429c33c1d069ccdcd">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00136.html">simple_partitioner</a> &amp;partitioner)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00136.html" title="A simple partitioner.">simple_partitioner</a>.  <a href="a00249.html#gabd49b7d7f63dc92429c33c1d069ccdcd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga0cecf9a429cd7ac8a5aa78b16b4ca635">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00019.html">auto_partitioner</a> &amp;partitioner)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00019.html" title="An auto partitioner.">auto_partitioner</a>.  <a href="a00249.html#ga0cecf9a429cd7ac8a5aa78b16b4ca635"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga4f4a29c725a3710773be023af003b9fc">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, <a class="el" href="a00003.html">affinity_partitioner</a> &amp;partitioner)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00003.html" title="An affinity partitioner.">affinity_partitioner</a>.  <a href="a00249.html#ga4f4a29c725a3710773be023af003b9fc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga7a6265e951dfeb9b88dbdf76777a45a0">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00136.html">simple_partitioner</a> &amp;partitioner, <a class="el" href="a00149.html">task_group_context</a> &amp;context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, simple partitioner and user-supplied context.  <a href="a00249.html#ga7a6265e951dfeb9b88dbdf76777a45a0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gaa3733a5e32f4eada6ba70c0b82800f4d">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00019.html">auto_partitioner</a> &amp;partitioner, <a class="el" href="a00149.html">task_group_context</a> &amp;context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00019.html" title="An auto partitioner.">auto_partitioner</a> and user-supplied context.  <a href="a00249.html#gaa3733a5e32f4eada6ba70c0b82800f4d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga21b6569b0503cca66b416f4ec7d43115">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, <a class="el" href="a00003.html">affinity_partitioner</a> &amp;partitioner, <a class="el" href="a00149.html">task_group_context</a> &amp;context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00003.html" title="An affinity partitioner.">affinity_partitioner</a> and user-supplied context.  <a href="a00249.html#ga21b6569b0503cca66b416f4ec7d43115"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga35ec7bc7b290da23aade5720dd145029">parallel_deterministic_reduce</a> (const Range &amp;range, Body &amp;body)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with deterministic reduction and default partitioner.  <a href="a00249.html#ga35ec7bc7b290da23aade5720dd145029"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga2ab8956163947123876467dcbcbb5efe">parallel_deterministic_reduce</a> (const Range &amp;range, Body &amp;body, <a class="el" href="a00149.html">task_group_context</a> &amp;context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with deterministic reduction, simple partitioner and user-supplied context.  <a href="a00249.html#ga2ab8956163947123876467dcbcbb5efe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gaf70b6fe2200079155f8c7df482e2701d">parallel_deterministic_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with deterministic reduction and default partitioner.  <a href="a00249.html#gaf70b6fe2200079155f8c7df482e2701d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gaa2e76735ef24d8630fc5288af0c2590a">parallel_deterministic_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, <a class="el" href="a00149.html">task_group_context</a> &amp;context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with deterministic reduction, simple partitioner and user-supplied context.  <a href="a00249.html#gaa2e76735ef24d8630fc5288af0c2590a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">parallel_scan</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpea856f699c9d234ea9f5ed535b0b16bb"></a> See also requirements on <a class="el" href="range_req.html">Range</a> and <a class="el" href="parallel_scan_body_req.html">parallel_scan Body</a>. </p>
<br/><br/></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gad337596ece330206040f6488a19b6779">parallel_scan</a> (const Range &amp;range, Body &amp;body)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel prefix with default partitioner.  <a href="a00249.html#gad337596ece330206040f6488a19b6779"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga2a2e1a2939691abfd1e1ff3874104a44">parallel_scan</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00136.html">simple_partitioner</a> &amp;partitioner)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel prefix with <a class="el" href="a00136.html" title="A simple partitioner.">simple_partitioner</a>.  <a href="a00249.html#ga2a2e1a2939691abfd1e1ff3874104a44"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gab29140dc991625ed05c9f8fe1526ea96">parallel_scan</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00019.html">auto_partitioner</a> &amp;partitioner)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel prefix with <a class="el" href="a00019.html" title="An auto partitioner.">auto_partitioner</a>.  <a href="a00249.html#gab29140dc991625ed05c9f8fe1526ea96"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">parallel_sort</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp507087c4dcfb051fe7d24227c3a34024"></a> See also requirements on <a class="el" href="parallel_sort_iter_req.html">iterators for parallel_sort</a>. </p>
<br/><br/></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator , typename Compare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga95e48e87618aa34aa88619ae06c3d81d">parallel_sort</a> (RandomAccessIterator begin, RandomAccessIterator end, const Compare &amp;comp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the data in [begin,end) using the given comparator.  <a href="a00249.html#ga95e48e87618aa34aa88619ae06c3d81d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga04aec2bd09cc56812b8ab2a2f24568ad">parallel_sort</a> (RandomAccessIterator begin, RandomAccessIterator end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the data in [begin,end) with a default comparator <code>std::less&lt;RandomAccessIterator&gt;</code>.  <a href="a00249.html#ga04aec2bd09cc56812b8ab2a2f24568ad"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga7204c5b60eb4ac1eb325c60e0bfe42a9">parallel_sort</a> (T *begin, T *end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the data in the range <code></code>[begin,end) with a default comparator <code>std::less&lt;T&gt;</code>.  <a href="a00249.html#ga7204c5b60eb4ac1eb325c60e0bfe42a9"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The namespace <a class="el" href="a00236.html" title="The namespace tbb contains all components of the library.">tbb</a> contains all components of the library. </p>
<p>This header provides basic platform abstraction layer by hooking up appropriate architecture/OS/compiler specific headers from the /include/tbb/machine directory. If a plug-in header does not implement all the required APIs, it must specify the missing ones by setting one or more of the following macros:</p>
<p>__TBB_USE_GENERIC_PART_WORD_CAS __TBB_USE_GENERIC_PART_WORD_FETCH_ADD __TBB_USE_GENERIC_PART_WORD_FETCH_STORE __TBB_USE_GENERIC_FETCH_ADD __TBB_USE_GENERIC_FETCH_STORE __TBB_USE_GENERIC_DWORD_FETCH_ADD __TBB_USE_GENERIC_DWORD_FETCH_STORE __TBB_USE_GENERIC_HALF_FENCED_LOAD_STORE __TBB_USE_GENERIC_FULL_FENCED_LOAD_STORE __TBB_USE_GENERIC_RELAXED_LOAD_STORE __TBB_USE_FETCHSTORE_AS_FULL_FENCED_STORE</p>
<p>In this case <a class="el" href="a00225_source.html">tbb_machine.h</a> will add missing functionality based on a minimal set of APIs that are required to be implemented by all plug-n headers as described further. Note that these generic implementations may be sub-optimal for a particular architecture, and thus should be relied upon only after careful evaluation or as the last resort.</p>
<p>Additionally __TBB_64BIT_ATOMICS can be set to 0 on a 32-bit architecture to indicate that the port is not going to support double word atomics. It may also be set to 1 explicitly, though normally this is not necessary as <a class="el" href="a00225_source.html">tbb_machine.h</a> will set it automatically.</p>
<p>__TBB_BIG_ENDIAN macro can be defined by the implementation as well. It is used only if the __TBB_USE_GENERIC_PART_WORD_CAS is set. Possible values are:</p>
<ul>
<li>1 if the system is big endian,</li>
<li>0 if it is little endian,</li>
<li>or -1 to explicitly state that __TBB_USE_GENERIC_PART_WORD_CAS can not be used. -1 should be used when it is known in advance that endianness can change in run time or it is not simple big or little but something more complex. The system will try to detect it in run time if it is not set(in assumption that it is either a big or little one).</li>
</ul>
<p>Prerequisites for each architecture port ---------------------------------------- The following functions and macros have no generic implementation. Therefore they must be implemented in each machine architecture specific header either as a conventional function or as a functional macro.</p>
<p>__TBB_WORDSIZE This is the size of machine word in bytes, i.e. for 32 bit systems it should be defined to 4.</p>
<p>__TBB_Yield() Signals OS that the current thread is willing to relinquish the remainder of its time quantum.</p>
<p>__TBB_full_memory_fence() Must prevent all memory operations from being reordered across it (both by hardware and compiler). All such fences must be totally ordered (or sequentially consistent).</p>
<p>__TBB_machine_cmpswp4( volatile void *ptr, int32_t value, int32_t comparand ) Must be provided if __TBB_USE_FENCED_ATOMICS is not set.</p>
<p>__TBB_machine_cmpswp8( volatile void *ptr, int32_t value, int64_t comparand ) Must be provided for 64-bit architectures if __TBB_USE_FENCED_ATOMICS is not set, and for 32-bit architectures if __TBB_64BIT_ATOMICS is set</p>
<p>__TBB_machine_&lt;op&gt;&lt;S&gt;&lt;fence&gt;(...), where &lt;op&gt; = {cmpswp, fetchadd, fetchstore} &lt;S&gt; = {1, 2, 4, 8} &lt;fence&gt; = {full_fence, acquire, release, relaxed} Must be provided if __TBB_USE_FENCED_ATOMICS is set.</p>
<p>__TBB_control_consistency_helper() Bridges the memory-semantics gap between architectures providing only implicit C++0x "consume" semantics (like Power Architecture) and those also implicitly obeying control dependencies (like IA-64). It must be used only in conditional code where the condition is itself data-dependent, and will then make subsequent code behave as if the original data dependency were acquired. It needs only a compiler fence where implied by the architecture either specifically (like IA-64) or because generally stronger "acquire" semantics are enforced (like x86). It is always valid, though potentially suboptimal, to replace control with acquire on the load and then remove the helper.</p>
<p>__TBB_acquire_consistency_helper(), __TBB_release_consistency_helper() Must be provided if __TBB_USE_GENERIC_HALF_FENCED_LOAD_STORE is set. Enforce acquire and release semantics in generic implementations of fenced store and load operations. Depending on the particular architecture/compiler combination they may be a hardware fence, a compiler fence, both or nothing. </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="adb86d08473679d6fe0eabcdc766ffe3a"></a><!-- doxytag: member="tbb::memory_semantics" ref="adb86d08473679d6fe0eabcdc766ffe3a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00236.html#adb86d08473679d6fe0eabcdc766ffe3a">tbb::memory_semantics</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specifies memory semantics. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="adb86d08473679d6fe0eabcdc766ffe3aa6a315190cf4509ec388ecb423432f36a"></a><!-- doxytag: member="full_fence" ref="adb86d08473679d6fe0eabcdc766ffe3aa6a315190cf4509ec388ecb423432f36a" args="" -->full_fence</em>&nbsp;</td><td>
<p>Sequential consistency. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adb86d08473679d6fe0eabcdc766ffe3aaa92646b4dc7618530d3a9f51dd10a418"></a><!-- doxytag: member="acquire" ref="adb86d08473679d6fe0eabcdc766ffe3aaa92646b4dc7618530d3a9f51dd10a418" args="" -->acquire</em>&nbsp;</td><td>
<p>Acquire. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adb86d08473679d6fe0eabcdc766ffe3aa412563418e657114a102db610f726632"></a><!-- doxytag: member="release" ref="adb86d08473679d6fe0eabcdc766ffe3aa412563418e657114a102db610f726632" args="" -->release</em>&nbsp;</td><td>
<p>Release. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5"></a><!-- doxytag: member="relaxed" ref="adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5" args="" -->relaxed</em>&nbsp;</td><td>
<p>No ordering. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ade8a8bc300d5ef09d38cbfb8baff5cd2"></a><!-- doxytag: member="tbb::TBB_runtime_interface_version" ref="ade8a8bc300d5ef09d38cbfb8baff5cd2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __TBB_EXPORTED_FUNC tbb::TBB_runtime_interface_version </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The function returns the interface version of the TBB shared library being used. </p>
<p>The version it returns is determined at runtime, not at compile/link time. So it can be different than the value of TBB_INTERFACE_VERSION obtained at compile time. </p>

</div>
</div>
</div>
<hr>
<p></p>
Copyright &copy; 2005-2013 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
