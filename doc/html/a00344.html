<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>tbb::task Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="a00423.html">tbb</a>::<a class="el" href="a00344.html">task</a></div>
<h1>tbb::task Class Reference<br>
<small>
[<a class="el" href="a00441.html">Task Scheduling</a>]</small>
</h1><!-- doxytag: class="tbb::task" -->Base class for user-defined tasks.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="a00624.html">task.h</a>&gt;</code>
<p>
<p>Inheritance diagram for tbb::task:
<p><center><img src="a00344.png" usemap="#tbb::task_map" border="0" alt=""></center>
<map name="tbb::task_map">
<area href="a00287.html" alt="tbb::empty_task" shape="rect" coords="0,56,97,80">
</map>
<a href="a00133.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef internal::affinity_id&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#e40960dfb45c324ce313ace20029c427">affinity_id</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An id as used for specifying affinity.  <a href="#e40960dfb45c324ce313ace20029c427"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#3935129602baa0b18727f8fc7384dbf1e450c433161eef2e97881924b0a5ffba">executing</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">task is running, and will be destroyed after method <a class="el" href="a00344.html#092e58368b7684207bd3020c6d104f2a">execute()</a> completes.  <a href="#3935129602baa0b18727f8fc7384dbf1e450c433161eef2e97881924b0a5ffba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#3935129602baa0b18727f8fc7384dbf1a20ac4d74e3124043471d357d786daf3">reexecute</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">task to be rescheduled.  <a href="#3935129602baa0b18727f8fc7384dbf1a20ac4d74e3124043471d357d786daf3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#3935129602baa0b18727f8fc7384dbf1b2cde487a169988d66fc1052cedc92dc">ready</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">task is in ready pool, or is going to be put there, or was just taken off.  <a href="#3935129602baa0b18727f8fc7384dbf1b2cde487a169988d66fc1052cedc92dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#3935129602baa0b18727f8fc7384dbf18d74b73d7ceaf5341c9c2552d6c68084">allocated</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">task object is freshly allocated or recycled.  <a href="#3935129602baa0b18727f8fc7384dbf18d74b73d7ceaf5341c9c2552d6c68084"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#3935129602baa0b18727f8fc7384dbf1d5877992ceab99813e0aa790420504de">freed</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">task object is on free list, or is going to be put there, or was just taken off.  <a href="#3935129602baa0b18727f8fc7384dbf1d5877992ceab99813e0aa790420504de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#3935129602baa0b18727f8fc7384dbf10e8b8338e4fd9cf8928be788540f878b">recycle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">task to be recycled as continuation  <a href="#3935129602baa0b18727f8fc7384dbf10e8b8338e4fd9cf8928be788540f878b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#3935129602baa0b18727f8fc7384dbf1">state_type</a> { <br>
&nbsp;&nbsp;<a class="el" href="a00344.html#3935129602baa0b18727f8fc7384dbf1e450c433161eef2e97881924b0a5ffba">executing</a>, 
<a class="el" href="a00344.html#3935129602baa0b18727f8fc7384dbf1a20ac4d74e3124043471d357d786daf3">reexecute</a>, 
<a class="el" href="a00344.html#3935129602baa0b18727f8fc7384dbf1b2cde487a169988d66fc1052cedc92dc">ready</a>, 
<a class="el" href="a00344.html#3935129602baa0b18727f8fc7384dbf18d74b73d7ceaf5341c9c2552d6c68084">allocated</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="a00344.html#3935129602baa0b18727f8fc7384dbf1d5877992ceab99813e0aa790420504de">freed</a>, 
<a class="el" href="a00344.html#3935129602baa0b18727f8fc7384dbf10e8b8338e4fd9cf8928be788540f878b">recycle</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumeration of task states that the scheduler considers.  <a href="a00344.html#3935129602baa0b18727f8fc7384dbf1">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bfe0ea7fd877987b03ddc466404389e7"></a><!-- doxytag: member="tbb::task::~task" ref="bfe0ea7fd877987b03ddc466404389e7" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#bfe0ea7fd877987b03ddc466404389e7">~task</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="092e58368b7684207bd3020c6d104f2a"></a><!-- doxytag: member="tbb::task::execute" ref="092e58368b7684207bd3020c6d104f2a" args="()=0" -->
virtual <a class="el" href="a00344.html">task</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#092e58368b7684207bd3020c6d104f2a">execute</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Should be overridden by derived classes. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">internal::allocate_continuation_proxy &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#3d541e86f39624d4cb8f8c90a39e57f9">allocate_continuation</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns proxy for overloaded new that allocates a continuation task of *this.  <a href="#3d541e86f39624d4cb8f8c90a39e57f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="94c4982c71c3794f3cbb12434eb3498a"></a><!-- doxytag: member="tbb::task::allocate_child" ref="94c4982c71c3794f3cbb12434eb3498a" args="()" -->
internal::allocate_child_proxy &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#94c4982c71c3794f3cbb12434eb3498a">allocate_child</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns proxy for overloaded new that allocates a child task of *this. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#1080aedc3bcbbcfa8c7c894d9d477ee6">destroy</a> (<a class="el" href="a00344.html">task</a> &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a task.  <a href="#1080aedc3bcbbcfa8c7c894d9d477ee6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#725edf7e253dfd8fb47638b31e3be898">recycle_as_continuation</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change this to be a continuation of its former self.  <a href="#725edf7e253dfd8fb47638b31e3be898"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#b095026979917d405f7bff17f3c4b482">recycle_as_safe_continuation</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recommended to use, safe variant of recycle_as_continuation.  <a href="#b095026979917d405f7bff17f3c4b482"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="52ad4704f6241097b1e8cc19c082c35e"></a><!-- doxytag: member="tbb::task::recycle_as_child_of" ref="52ad4704f6241097b1e8cc19c082c35e" args="(task &amp;new_parent)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#52ad4704f6241097b1e8cc19c082c35e">recycle_as_child_of</a> (<a class="el" href="a00344.html">task</a> &amp;new_parent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change this to be a child of new_parent. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#414ac430dfeec4795b781a8d00427c87">recycle_to_reexecute</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Schedule this for reexecution after current <a class="el" href="a00344.html#092e58368b7684207bd3020c6d104f2a">execute()</a> returns.  <a href="#414ac430dfeec4795b781a8d00427c87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="172f2c9ac56ed333fd0c41e4c9065cc6"></a><!-- doxytag: member="tbb::task::depth" ref="172f2c9ac56ed333fd0c41e4c9065cc6" args="() const " -->
intptr_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>depth</b> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6905bbb1ca0a21ec7d544146dc7d2044"></a><!-- doxytag: member="tbb::task::set_depth" ref="6905bbb1ca0a21ec7d544146dc7d2044" args="(intptr_t)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>set_depth</b> (intptr_t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f58e689399bc2ebe8e015e7ccf5b1d48"></a><!-- doxytag: member="tbb::task::add_to_depth" ref="f58e689399bc2ebe8e015e7ccf5b1d48" args="(int)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>add_to_depth</b> (int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ca4ee1355d9f6acfd34f736fa889f3fd"></a><!-- doxytag: member="tbb::task::set_ref_count" ref="ca4ee1355d9f6acfd34f736fa889f3fd" args="(int count)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#ca4ee1355d9f6acfd34f736fa889f3fd">set_ref_count</a> (int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set reference count. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#d073347530703d8ffb98b889a69f0ea4">increment_ref_count</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically increment reference count and returns its old value.  <a href="#d073347530703d8ffb98b889a69f0ea4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#488d3b726c893e91d8a625caf4cf96f3">decrement_ref_count</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically decrement reference count and returns its new value.  <a href="#488d3b726c893e91d8a625caf4cf96f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="99ea4f316479857b3de302bb0966ef72"></a><!-- doxytag: member="tbb::task::spawn_and_wait_for_all" ref="99ea4f316479857b3de302bb0966ef72" args="(task &amp;child)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#99ea4f316479857b3de302bb0966ef72">spawn_and_wait_for_all</a> (<a class="el" href="a00344.html">task</a> &amp;child)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to spawn followed by wait_for_all, but more efficient. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d4c9763941c0fbd35060a979872bf5e1"></a><!-- doxytag: member="tbb::task::spawn_and_wait_for_all" ref="d4c9763941c0fbd35060a979872bf5e1" args="(task_list &amp;list)" -->
void __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#d4c9763941c0fbd35060a979872bf5e1">spawn_and_wait_for_all</a> (<a class="el" href="a00349.html">task_list</a> &amp;list)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to spawn followed by wait_for_all, but more efficient. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#ab6be2d551d52d8d62a92ef87f3ec508">wait_for_all</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for reference count to become one, and set reference count to zero.  <a href="#ab6be2d551d52d8d62a92ef87f3ec508"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9d50759d59a2d300287158f38b317798"></a><!-- doxytag: member="tbb::task::parent" ref="9d50759d59a2d300287158f38b317798" args="() const " -->
<a class="el" href="a00344.html">task</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#9d50759d59a2d300287158f38b317798">parent</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">task on whose behalf this task is working, or NULL if this is a root. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="537d5c946c6715e0d76974dc53e616bc"></a><!-- doxytag: member="tbb::task::set_parent" ref="537d5c946c6715e0d76974dc53e616bc" args="(task *p)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#537d5c946c6715e0d76974dc53e616bc">set_parent</a> (<a class="el" href="a00344.html">task</a> *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets parent task pointer to specified value <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00347.html">task_group_context</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#da4ae99995a8f7b0cf1bbb6febbff8bb">context</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method is deprecated and will be removed in the future.  <a href="#da4ae99995a8f7b0cf1bbb6febbff8bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="750f29eb8526c15e171c90a7f2962603"></a><!-- doxytag: member="tbb::task::group" ref="750f29eb8526c15e171c90a7f2962603" args="()" -->
<a class="el" href="a00347.html">task_group_context</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#750f29eb8526c15e171c90a7f2962603">group</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the task group descriptor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0f1389831c34ae70c07537c1d4fd9ffb"></a><!-- doxytag: member="tbb::task::is_stolen_task" ref="0f1389831c34ae70c07537c1d4fd9ffb" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#0f1389831c34ae70c07537c1d4fd9ffb">is_stolen_task</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if task was stolen from the task pool of another thread. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="22ef8282e09458a46131843219cb71e5"></a><!-- doxytag: member="tbb::task::state" ref="22ef8282e09458a46131843219cb71e5" args="() const " -->
<a class="el" href="a00344.html#3935129602baa0b18727f8fc7384dbf1">state_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#22ef8282e09458a46131843219cb71e5">state</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current execution state. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b82188cc88d0306a706fac651621c4c8"></a><!-- doxytag: member="tbb::task::ref_count" ref="b82188cc88d0306a706fac651621c4c8" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#b82188cc88d0306a706fac651621c4c8">ref_count</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The internal reference count. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2a5b08efc1c6c413ad224a5d4dba5bc0"></a><!-- doxytag: member="tbb::task::is_owned_by_current_thread" ref="2a5b08efc1c6c413ad224a5d4dba5bc0" args="() const " -->
bool __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#2a5b08efc1c6c413ad224a5d4dba5bc0">is_owned_by_current_thread</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obsolete, and only retained for the sake of backward compatibility. Always returns true. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b9145d7f0f59589ff43db878766abf43"></a><!-- doxytag: member="tbb::task::set_affinity" ref="b9145d7f0f59589ff43db878766abf43" args="(affinity_id id)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#b9145d7f0f59589ff43db878766abf43">set_affinity</a> (<a class="el" href="a00344.html#e40960dfb45c324ce313ace20029c427">affinity_id</a> id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set affinity for this task. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fa6b377971d086ee8eda49873f87430a"></a><!-- doxytag: member="tbb::task::affinity" ref="fa6b377971d086ee8eda49873f87430a" args="() const " -->
<a class="el" href="a00344.html#e40960dfb45c324ce313ace20029c427">affinity_id</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#fa6b377971d086ee8eda49873f87430a">affinity</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current affinity of this task. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#8b83277e8e5ec5c51d7a0bc654753d7c">note_affinity</a> (<a class="el" href="a00344.html#e40960dfb45c324ce313ace20029c427">affinity_id</a> id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invoked by scheduler to notify task that it ran on unexpected thread.  <a href="#8b83277e8e5ec5c51d7a0bc654753d7c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#08be5c3a725bd39440411aef2a420bf5">change_group</a> (<a class="el" href="a00347.html">task_group_context</a> &amp;ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves this task from its current group into another one.  <a href="#08be5c3a725bd39440411aef2a420bf5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#5fb363a9917f1b6b24d3b053e9b5f2a6">cancel_group_execution</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initiates cancellation of all tasks in this cancellation group and its subordinate groups.  <a href="#5fb363a9917f1b6b24d3b053e9b5f2a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="540796b339aa9e5bd08cad1cc91da84b"></a><!-- doxytag: member="tbb::task::is_cancelled" ref="540796b339aa9e5bd08cad1cc91da84b" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#540796b339aa9e5bd08cad1cc91da84b">is_cancelled</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the context has received cancellation request. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1554fbbaf37f47adab31bb8c8ebd047b"></a><!-- doxytag: member="tbb::task::set_group_priority" ref="1554fbbaf37f47adab31bb8c8ebd047b" args="(priority_t p)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#1554fbbaf37f47adab31bb8c8ebd047b">set_group_priority</a> (priority_t p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes priority of the task group this task belongs to. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="98e779cff1734479d8ad7f732000a165"></a><!-- doxytag: member="tbb::task::group_priority" ref="98e779cff1734479d8ad7f732000a165" args="() const " -->
priority_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#98e779cff1734479d8ad7f732000a165">group_priority</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves current priority of the task group this task belongs to. <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c7a9405b422bec9110854acd71edb9f2"></a><!-- doxytag: member="tbb::task::allocate_root" ref="c7a9405b422bec9110854acd71edb9f2" args="()" -->
static internal::allocate_root_proxy&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#c7a9405b422bec9110854acd71edb9f2">allocate_root</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns proxy for overloaded new that allocates a root task. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e812b7fb5cab409372fe347dbbd38304"></a><!-- doxytag: member="tbb::task::allocate_root" ref="e812b7fb5cab409372fe347dbbd38304" args="(task_group_context &amp;ctx)" -->
static internal::allocate_root_with_context_proxy&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#e812b7fb5cab409372fe347dbbd38304">allocate_root</a> (<a class="el" href="a00347.html">task_group_context</a> &amp;ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns proxy for overloaded new that allocates a root task associated with user supplied context. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f19c8ef47d1feb6dae459a99efb8bd31"></a><!-- doxytag: member="tbb::task::spawn_root_and_wait" ref="f19c8ef47d1feb6dae459a99efb8bd31" args="(task &amp;root)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#f19c8ef47d1feb6dae459a99efb8bd31">spawn_root_and_wait</a> (<a class="el" href="a00344.html">task</a> &amp;root)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spawn task allocated by allocate_root, wait for it to complete, and deallocate it. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#093a4da885180ae584a56fb7c02e4c38">spawn_root_and_wait</a> (<a class="el" href="a00349.html">task_list</a> &amp;root_list)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spawn root tasks on list and wait for all of them to finish.  <a href="#093a4da885180ae584a56fb7c02e4c38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#391face6a5f6fee8eef31c737106ba7e">enqueue</a> (<a class="el" href="a00344.html">task</a> &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue task for starvation-resistant execution.  <a href="#391face6a5f6fee8eef31c737106ba7e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ef93f12f35325660e03b31cabbb01b77"></a><!-- doxytag: member="tbb::task::enqueue" ref="ef93f12f35325660e03b31cabbb01b77" args="(task &amp;t, priority_t p)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#ef93f12f35325660e03b31cabbb01b77">enqueue</a> (<a class="el" href="a00344.html">task</a> &amp;t, priority_t p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue task for starvation-resistant execution on the specified priority level. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="898b1552bb4039567e5c1bb2fc3ff943"></a><!-- doxytag: member="tbb::task::self" ref="898b1552bb4039567e5c1bb2fc3ff943" args="()" -->
static <a class="el" href="a00344.html">task</a> &amp;__TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#898b1552bb4039567e5c1bb2fc3ff943">self</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The innermost task being executed or destroyed by the current thread at the moment. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d2d9c5ec51ef240a72130480b5a25638"></a><!-- doxytag: member="tbb::task::task" ref="d2d9c5ec51ef240a72130480b5a25638" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html#d2d9c5ec51ef240a72130480b5a25638">task</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor. <br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="df87ea5e683e46dd666d260142796961"></a><!-- doxytag: member="tbb::task::interface5::internal::task_base" ref="df87ea5e683e46dd666d260142796961" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>interface5::internal::task_base</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="95a8ebd4b4310ccd0075da4df02103ea"></a><!-- doxytag: member="tbb::task::task_list" ref="95a8ebd4b4310ccd0075da4df02103ea" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>task_list</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9ebef2625215e8ed6836bb15990adce1"></a><!-- doxytag: member="tbb::task::internal::scheduler" ref="9ebef2625215e8ed6836bb15990adce1" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::scheduler</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c79a9aa664be4320b16a72110ff5c41c"></a><!-- doxytag: member="tbb::task::internal::allocate_root_proxy" ref="c79a9aa664be4320b16a72110ff5c41c" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::allocate_root_proxy</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="26855f4e884eee14d49f2ba7b8cd1dcf"></a><!-- doxytag: member="tbb::task::internal::allocate_root_with_context_proxy" ref="26855f4e884eee14d49f2ba7b8cd1dcf" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::allocate_root_with_context_proxy</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6315640eb4a3d4ff0bf38d82e855a23d"></a><!-- doxytag: member="tbb::task::internal::allocate_continuation_proxy" ref="6315640eb4a3d4ff0bf38d82e855a23d" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::allocate_continuation_proxy</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="120ae94a5f72146e3acddd6d782bd176"></a><!-- doxytag: member="tbb::task::internal::allocate_child_proxy" ref="120ae94a5f72146e3acddd6d782bd176" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::allocate_child_proxy</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f3a52fd61beaabc1c6b8ad04284d6925"></a><!-- doxytag: member="tbb::task::internal::allocate_additional_child_of_proxy" ref="f3a52fd61beaabc1c6b8ad04284d6925" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::allocate_additional_child_of_proxy</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Base class for user-defined tasks. 
<p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="e40960dfb45c324ce313ace20029c427"></a><!-- doxytag: member="tbb::task::affinity_id" ref="e40960dfb45c324ce313ace20029c427" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::affinity_id <a class="el" href="a00344.html#e40960dfb45c324ce313ace20029c427">tbb::task::affinity_id</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An id as used for specifying affinity. 
<p>
Guaranteed to be integral type. Value of 0 means no affinity. 
</div>
</div><p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="3935129602baa0b18727f8fc7384dbf1"></a><!-- doxytag: member="tbb::task::state_type" ref="3935129602baa0b18727f8fc7384dbf1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00344.html#3935129602baa0b18727f8fc7384dbf1">tbb::task::state_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enumeration of task states that the scheduler considers. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="3935129602baa0b18727f8fc7384dbf1e450c433161eef2e97881924b0a5ffba"></a><!-- doxytag: member="executing" ref="3935129602baa0b18727f8fc7384dbf1e450c433161eef2e97881924b0a5ffba" args="" -->executing</em>&nbsp;</td><td>
task is running, and will be destroyed after method <a class="el" href="a00344.html#092e58368b7684207bd3020c6d104f2a">execute()</a> completes. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="3935129602baa0b18727f8fc7384dbf1a20ac4d74e3124043471d357d786daf3"></a><!-- doxytag: member="reexecute" ref="3935129602baa0b18727f8fc7384dbf1a20ac4d74e3124043471d357d786daf3" args="" -->reexecute</em>&nbsp;</td><td>
task to be rescheduled. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="3935129602baa0b18727f8fc7384dbf1b2cde487a169988d66fc1052cedc92dc"></a><!-- doxytag: member="ready" ref="3935129602baa0b18727f8fc7384dbf1b2cde487a169988d66fc1052cedc92dc" args="" -->ready</em>&nbsp;</td><td>
task is in ready pool, or is going to be put there, or was just taken off. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="3935129602baa0b18727f8fc7384dbf18d74b73d7ceaf5341c9c2552d6c68084"></a><!-- doxytag: member="allocated" ref="3935129602baa0b18727f8fc7384dbf18d74b73d7ceaf5341c9c2552d6c68084" args="" -->allocated</em>&nbsp;</td><td>
task object is freshly allocated or recycled. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="3935129602baa0b18727f8fc7384dbf1d5877992ceab99813e0aa790420504de"></a><!-- doxytag: member="freed" ref="3935129602baa0b18727f8fc7384dbf1d5877992ceab99813e0aa790420504de" args="" -->freed</em>&nbsp;</td><td>
task object is on free list, or is going to be put there, or was just taken off. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="3935129602baa0b18727f8fc7384dbf10e8b8338e4fd9cf8928be788540f878b"></a><!-- doxytag: member="recycle" ref="3935129602baa0b18727f8fc7384dbf10e8b8338e4fd9cf8928be788540f878b" args="" -->recycle</em>&nbsp;</td><td>
task to be recycled as continuation </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="3d541e86f39624d4cb8f8c90a39e57f9"></a><!-- doxytag: member="tbb::task::allocate_continuation" ref="3d541e86f39624d4cb8f8c90a39e57f9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::allocate_continuation_proxy&amp; tbb::task::allocate_continuation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns proxy for overloaded new that allocates a continuation task of *this. 
<p>
The continuation's parent becomes the parent of *this. 
</div>
</div><p>
<a class="anchor" name="5fb363a9917f1b6b24d3b053e9b5f2a6"></a><!-- doxytag: member="tbb::task::cancel_group_execution" ref="5fb363a9917f1b6b24d3b053e9b5f2a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tbb::task::cancel_group_execution           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initiates cancellation of all tasks in this cancellation group and its subordinate groups. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>false if cancellation has already been requested, true otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="08be5c3a725bd39440411aef2a420bf5"></a><!-- doxytag: member="tbb::task::change_group" ref="08be5c3a725bd39440411aef2a420bf5" args="(task_group_context &amp;ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __TBB_EXPORTED_METHOD tbb::task::change_group           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00347.html">task_group_context</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves this task from its current group into another one. 
<p>
Argument ctx specifies the new group.<p>
The primary purpose of this method is to associate unique task group context with a task allocated for subsequent enqueuing. In contrast to spawned tasks enqueued ones normally outlive the scope where they were created. This makes traditional usage model where task group context are allocated locally on the stack inapplicable. Dynamic allocation of context objects is performance inefficient. Method <a class="el" href="a00344.html#08be5c3a725bd39440411aef2a420bf5">change_group()</a> allows to make task group context object a member of the task class, and then associate it with its containing task object in the latter's constructor. 
</div>
</div><p>
<a class="anchor" name="da4ae99995a8f7b0cf1bbb6febbff8bb"></a><!-- doxytag: member="tbb::task::context" ref="da4ae99995a8f7b0cf1bbb6febbff8bb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00347.html">task_group_context</a>* tbb::task::context           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is deprecated and will be removed in the future. 
<p>
Use method <a class="el" href="a00344.html#750f29eb8526c15e171c90a7f2962603">group()</a> instead. 
</div>
</div><p>
<a class="anchor" name="488d3b726c893e91d8a625caf4cf96f3"></a><!-- doxytag: member="tbb::task::decrement_ref_count" ref="488d3b726c893e91d8a625caf4cf96f3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tbb::task::decrement_ref_count           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Atomically decrement reference count and returns its new value. 
<p>
Has release semantics. 
</div>
</div><p>
<a class="anchor" name="1080aedc3bcbbcfa8c7c894d9d477ee6"></a><!-- doxytag: member="tbb::task::destroy" ref="1080aedc3bcbbcfa8c7c894d9d477ee6" args="(task &amp;t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __TBB_EXPORTED_METHOD tbb::task::destroy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00344.html">task</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy a task. 
<p>
Usually, calling this method is unnecessary, because a task is implicitly deleted after its <a class="el" href="a00344.html#092e58368b7684207bd3020c6d104f2a">execute()</a> method runs. However, sometimes a task needs to be explicitly deallocated, such as when a root task is used as the parent in spawn_and_wait_for_all. 
</div>
</div><p>
<a class="anchor" name="391face6a5f6fee8eef31c737106ba7e"></a><!-- doxytag: member="tbb::task::enqueue" ref="391face6a5f6fee8eef31c737106ba7e" args="(task &amp;t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void tbb::task::enqueue           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00344.html">task</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enqueue task for starvation-resistant execution. 
<p>
The task will be enqueued on the normal priority level disregarding the priority of its task group.<p>
The rationale of such semantics is that priority of an enqueued task is statically fixed at the moment of its enqueuing, while task group priority is dynamic. Thus automatic priority inheritance would be generally a subject to the race, which may result in unexpected behavior.<p>
Use <a class="el" href="a00344.html#391face6a5f6fee8eef31c737106ba7e">enqueue()</a> overload with explicit priority value and <a class="el" href="a00344.html#98e779cff1734479d8ad7f732000a165">task::group_priority()</a> method to implement such priority inheritance when it is really necessary. 
</div>
</div><p>
<a class="anchor" name="d073347530703d8ffb98b889a69f0ea4"></a><!-- doxytag: member="tbb::task::increment_ref_count" ref="d073347530703d8ffb98b889a69f0ea4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbb::task::increment_ref_count           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Atomically increment reference count and returns its old value. 
<p>
Has acquire semantics 
</div>
</div><p>
<a class="anchor" name="8b83277e8e5ec5c51d7a0bc654753d7c"></a><!-- doxytag: member="tbb::task::note_affinity" ref="8b83277e8e5ec5c51d7a0bc654753d7c" args="(affinity_id id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void __TBB_EXPORTED_METHOD tbb::task::note_affinity           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00344.html#e40960dfb45c324ce313ace20029c427">affinity_id</a>&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invoked by scheduler to notify task that it ran on unexpected thread. 
<p>
Invoked before method <a class="el" href="a00344.html#092e58368b7684207bd3020c6d104f2a">execute()</a> runs, if task is stolen, or task has affinity but will be executed on another thread.<p>
The default action does nothing. 
</div>
</div><p>
<a class="anchor" name="725edf7e253dfd8fb47638b31e3be898"></a><!-- doxytag: member="tbb::task::recycle_as_continuation" ref="725edf7e253dfd8fb47638b31e3be898" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbb::task::recycle_as_continuation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change this to be a continuation of its former self. 
<p>
The caller must guarantee that the task's refcount does not become zero until after the method <a class="el" href="a00344.html#092e58368b7684207bd3020c6d104f2a">execute()</a> returns. Typically, this is done by having method <a class="el" href="a00344.html#092e58368b7684207bd3020c6d104f2a">execute()</a> return a pointer to a child of the task. If the guarantee cannot be made, use method recycle_as_safe_continuation instead.<p>
Because of the hazard, this method may be deprecated in the future. 
</div>
</div><p>
<a class="anchor" name="b095026979917d405f7bff17f3c4b482"></a><!-- doxytag: member="tbb::task::recycle_as_safe_continuation" ref="b095026979917d405f7bff17f3c4b482" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbb::task::recycle_as_safe_continuation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recommended to use, safe variant of recycle_as_continuation. 
<p>
For safety, it requires additional increment of ref_count. With no descendants and ref_count of 1, it has the semantics of recycle_to_reexecute. 
</div>
</div><p>
<a class="anchor" name="414ac430dfeec4795b781a8d00427c87"></a><!-- doxytag: member="tbb::task::recycle_to_reexecute" ref="414ac430dfeec4795b781a8d00427c87" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbb::task::recycle_to_reexecute           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Schedule this for reexecution after current <a class="el" href="a00344.html#092e58368b7684207bd3020c6d104f2a">execute()</a> returns. 
<p>
Made obsolete by recycle_as_safe_continuation; may become deprecated. 
</div>
</div><p>
<a class="anchor" name="093a4da885180ae584a56fb7c02e4c38"></a><!-- doxytag: member="tbb::task::spawn_root_and_wait" ref="093a4da885180ae584a56fb7c02e4c38" args="(task_list &amp;root_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbb::task::spawn_root_and_wait           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00349.html">task_list</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>root_list</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Spawn root tasks on list and wait for all of them to finish. 
<p>
If there are more tasks than worker threads, the tasks are spawned in order of front to back. 
</div>
</div><p>
<a class="anchor" name="ab6be2d551d52d8d62a92ef87f3ec508"></a><!-- doxytag: member="tbb::task::wait_for_all" ref="ab6be2d551d52d8d62a92ef87f3ec508" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbb::task::wait_for_all           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for reference count to become one, and set reference count to zero. 
<p>
Works on tasks while waiting. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00624.html">task.h</a></ul>
<hr>
<p></p>
Copyright &copy; 2005-2012 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
