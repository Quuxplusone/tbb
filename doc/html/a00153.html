<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>tbb::task_scheduler_init Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="a00236.html">tbb</a>::<a class="el" href="a00153.html">task_scheduler_init</a>
  </div>
</div>
<div class="contents">
<h1>tbb::task_scheduler_init Class Reference<br/>
<small>
[<a class="el" href="a00254.html">Task Scheduling</a>]</small>
</h1><!-- doxytag: class="tbb::task_scheduler_init" -->
<p><code>#include &lt;<a class="el" href="a00219_source.html">task_scheduler_init.h</a>&gt;</code></p>

<p><a href="a00311.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00153.html#a485028b867bffef5829209330e79e64c">initialize</a> (int number_of_threads=<a class="el" href="a00153.html#a945886f5ef48300a8ebff2d077c166b1">automatic</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ensure that scheduler exists for this thread.  <a href="#a485028b867bffef5829209330e79e64c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00153.html#a0f5294f74b123a646a1762c68d11e39a">initialize</a> (int number_of_threads, stack_size_type thread_stack_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The overloaded method with stack size parameter.  <a href="#a0f5294f74b123a646a1762c68d11e39a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15d5dca7f79c5769bb96f674e4da0c04"></a><!-- doxytag: member="tbb::task_scheduler_init::terminate" ref="a15d5dca7f79c5769bb96f674e4da0c04" args="()" -->
void __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00153.html#a15d5dca7f79c5769bb96f674e4da0c04">terminate</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inverse of method initialize. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a686cfb03a673cb0ddd31f8e48051a79f"></a><!-- doxytag: member="tbb::task_scheduler_init::task_scheduler_init" ref="a686cfb03a673cb0ddd31f8e48051a79f" args="(int number_of_threads=automatic, stack_size_type thread_stack_size=0, bool wait_workers_in_terminate=false) task_scheduler_init(int number_of_threads" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00153.html#a686cfb03a673cb0ddd31f8e48051a79f">task_scheduler_init</a> (int number_of_threads=<a class="el" href="a00153.html#a945886f5ef48300a8ebff2d077c166b1">automatic</a>, stack_size_type thread_stack_size=0, bool wait_workers_in_terminate=false) <a class="el" href="a00153.html">task_scheduler_init</a>(int number_of_threads</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shorthand for default constructor followed by call to initialize(number_of_threads). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed5505d7fed9d5493676aa15c176512c"></a><!-- doxytag: member="tbb::task_scheduler_init::is_active" ref="aed5505d7fed9d5493676aa15c176512c" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00153.html#aed5505d7fed9d5493676aa15c176512c">is_active</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if scheduler is active (initialized); false otherwise. <br/></td></tr>
<tr><td colspan="2"><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">stack_size_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>thread_stack_size</b></td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a945886f5ef48300a8ebff2d077c166b1"></a><!-- doxytag: member="tbb::task_scheduler_init::automatic" ref="a945886f5ef48300a8ebff2d077c166b1" args="" -->
static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00153.html#a945886f5ef48300a8ebff2d077c166b1">automatic</a> = -1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef for number of threads that is automatic. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0e49ff2f59a4e53c9c07897b57f084d"></a><!-- doxytag: member="tbb::task_scheduler_init::deferred" ref="af0e49ff2f59a4e53c9c07897b57f084d" args="" -->
static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00153.html#af0e49ff2f59a4e53c9c07897b57f084d">deferred</a> = -2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Argument to <a class="el" href="a00153.html#a485028b867bffef5829209330e79e64c" title="Ensure that scheduler exists for this thread.">initialize()</a> or constructor that causes initialization to be deferred. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Class delimiting the scope of <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> scheduler activity. A thread can construct a <a class="el" href="a00153.html">task_scheduler_init</a> object and keep it alive while it uses TBB's tasking subsystem (including parallel algorithms).</p>
<p>This class allows to customize properties of the TBB <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> pool to some extent. For example it can limit concurrency level of parallel work initiated by the given thread. It also can be used to specify stack size of the TBB worker threads, though this setting is not effective if the thread pool has already been created.</p>
<p>If a parallel construct is used without <a class="el" href="a00153.html">task_scheduler_init</a> object previously created, the scheduler will be initialized automatically with default settings, and will persist until this thread exits. Default concurrency level is defined as described in <a class="el" href="a00153.html#a485028b867bffef5829209330e79e64c" title="Ensure that scheduler exists for this thread.">task_scheduler_init::initialize()</a>. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0f5294f74b123a646a1762c68d11e39a"></a><!-- doxytag: member="tbb::task_scheduler_init::initialize" ref="a0f5294f74b123a646a1762c68d11e39a" args="(int number_of_threads, stack_size_type thread_stack_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __TBB_EXPORTED_METHOD tbb::task_scheduler_init::initialize </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>number_of_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stack_size_type&nbsp;</td>
          <td class="paramname"> <em>thread_stack_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The overloaded method with stack size parameter. </p>
<p>Overloading is necessary to preserve ABI compatibility </p>

</div>
</div>
<a class="anchor" id="a485028b867bffef5829209330e79e64c"></a><!-- doxytag: member="tbb::task_scheduler_init::initialize" ref="a485028b867bffef5829209330e79e64c" args="(int number_of_threads=automatic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __TBB_EXPORTED_METHOD tbb::task_scheduler_init::initialize </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>number_of_threads</em> = <code><a class="el" href="a00153.html#a945886f5ef48300a8ebff2d077c166b1">automatic</a></code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ensure that scheduler exists for this thread. </p>
<p>A value of -1 lets TBB decide on the number of threads, which is usually maximal hardware concurrency for this process, that is the number of logical CPUs on the machine (possibly limited by the processor affinity mask of this process (Windows) or of this thread (Linux, FreeBSD). It is preferable option for production code because it helps to avoid nasty surprises when several TBB based components run side-by-side or in a nested fashion inside the same process.</p>
<p>The number_of_threads is ignored if any other task_scheduler_inits currently exist. A thread may construct multiple task_scheduler_inits. Doing so does no harm because the underlying scheduler is reference counted. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a9b65fb3ca218634df56b066b69dd3643"></a><!-- doxytag: member="tbb::task_scheduler_init::thread_stack_size" ref="a9b65fb3ca218634df56b066b69dd3643" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stack_size_type tbb::task_scheduler_init::thread_stack_size</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">0 )
#endif
  : my_scheduler(NULL)  {
        
        
        
        
        
        
        
        __TBB_ASSERT( !(thread_stack_size &amp; propagation_mode_mask), <span class="stringliteral">&quot;Requested stack size is not aligned&quot;</span> );
<span class="preprocessor">#if TBB_USE_EXCEPTIONS</span>
<span class="preprocessor"></span>        thread_stack_size |= TBB_USE_CAPTURED_EXCEPTION ? propagation_mode_captured : propagation_mode_exact;
<span class="preprocessor">#endif </span>
<span class="preprocessor"></span><span class="preprocessor">#if __TBB_SUPPORTS_WORKERS_WAITING_IN_TERMINATE</span>
<span class="preprocessor"></span>        <span class="keywordflow">if</span> (wait_workers_in_terminate)
            my_scheduler = (internal::scheduler*)wait_workers_in_terminate_flag;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        <a class="code" href="a00153.html#a485028b867bffef5829209330e79e64c" title="Ensure that scheduler exists for this thread.">initialize</a>( number_of_threads, thread_stack_size );
    }

    
    ~<a class="code" href="a00153.html#a686cfb03a673cb0ddd31f8e48051a79f" title="Shorthand for default constructor followed by call to initialize(number_of_threads)...">task_scheduler_init</a>() {
        <span class="keywordflow">if</span>( my_scheduler ) 
            <a class="code" href="a00153.html#a15d5dca7f79c5769bb96f674e4da0c04" title="Inverse of method initialize.">terminate</a>();
        internal::poison_pointer( my_scheduler );
    }
    
    
    <span class="keyword">static</span> <span class="keywordtype">int</span> __TBB_EXPORTED_FUNC default_num_threads ()
</pre></div>
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00219_source.html">task_scheduler_init.h</a></li>
</ul>
</div>
<hr>
<p></p>
Copyright &copy; 2005-2013 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
