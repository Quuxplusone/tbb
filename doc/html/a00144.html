<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>tbb::task Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="a00236.html">tbb</a>::<a class="el" href="a00144.html">task</a>
  </div>
</div>
<div class="contents">
<h1>tbb::task Class Reference<br/>
<small>
[<a class="el" href="a00254.html">Task Scheduling</a>]</small>
</h1><!-- doxytag: class="tbb::task" -->
<p>Base class for user-defined tasks.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00216_source.html">task.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tbb::task:</div>
<div class="dynsection">
 <div class="center">
  <img src="a00144.gif" usemap="#tbb::task_map" alt=""/>
  <map id="tbb::task_map" name="tbb::task_map">
<area href="a00054.html" alt="tbb::empty_task" shape="rect" coords="0,56,211,80"/>
<area href="a00064.html" alt="tbb::internal::function_task&lt; F &gt;" shape="rect" coords="221,56,432,80"/>
<area href="a00151.html" alt="tbb::internal::task_handle_task&lt; F &gt;" shape="rect" coords="442,56,653,80"/>
</map>
 </div>
</div>

<p><a href="a00305.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a3935129602baa0b18727f8fc7384dbf1">state_type</a> { <br/>
&nbsp;&nbsp;<a class="el" href="a00144.html#a3935129602baa0b18727f8fc7384dbf1ae450c433161eef2e97881924b0a5ffba">executing</a>, 
<a class="el" href="a00144.html#a3935129602baa0b18727f8fc7384dbf1aa20ac4d74e3124043471d357d786daf3">reexecute</a>, 
<a class="el" href="a00144.html#a3935129602baa0b18727f8fc7384dbf1ab2cde487a169988d66fc1052cedc92dc">ready</a>, 
<a class="el" href="a00144.html#a3935129602baa0b18727f8fc7384dbf1a8d74b73d7ceaf5341c9c2552d6c68084">allocated</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00144.html#a3935129602baa0b18727f8fc7384dbf1ad5877992ceab99813e0aa790420504de">freed</a>, 
<a class="el" href="a00144.html#a3935129602baa0b18727f8fc7384dbf1a0e8b8338e4fd9cf8928be788540f878b">recycle</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enumeration of <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> states that the scheduler considers. </p>
 <a href="a00144.html#a3935129602baa0b18727f8fc7384dbf1">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef internal::affinity_id&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#ae40960dfb45c324ce313ace20029c427">affinity_id</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An id as used for specifying affinity.  <a href="#ae40960dfb45c324ce313ace20029c427"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfe0ea7fd877987b03ddc466404389e7"></a><!-- doxytag: member="tbb::task::~task" ref="abfe0ea7fd877987b03ddc466404389e7" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#abfe0ea7fd877987b03ddc466404389e7">~task</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a092e58368b7684207bd3020c6d104f2a"></a><!-- doxytag: member="tbb::task::execute" ref="a092e58368b7684207bd3020c6d104f2a" args="()=0" -->
virtual <a class="el" href="a00144.html">task</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a092e58368b7684207bd3020c6d104f2a">execute</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Should be overridden by derived classes. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">internal::allocate_continuation_proxy &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a3d541e86f39624d4cb8f8c90a39e57f9">allocate_continuation</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns proxy for overloaded new that allocates a continuation <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> of *this.  <a href="#a3d541e86f39624d4cb8f8c90a39e57f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94c4982c71c3794f3cbb12434eb3498a"></a><!-- doxytag: member="tbb::task::allocate_child" ref="a94c4982c71c3794f3cbb12434eb3498a" args="()" -->
internal::allocate_child_proxy &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a94c4982c71c3794f3cbb12434eb3498a">allocate_child</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns proxy for overloaded new that allocates a child <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> of *this. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a1080aedc3bcbbcfa8c7c894d9d477ee6">destroy</a> (<a class="el" href="a00144.html">task</a> &amp;t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a>.  <a href="#a1080aedc3bcbbcfa8c7c894d9d477ee6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a725edf7e253dfd8fb47638b31e3be898">recycle_as_continuation</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change this to be a continuation of its former self.  <a href="#a725edf7e253dfd8fb47638b31e3be898"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#ab095026979917d405f7bff17f3c4b482">recycle_as_safe_continuation</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recommended to use, safe variant of recycle_as_continuation.  <a href="#ab095026979917d405f7bff17f3c4b482"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52ad4704f6241097b1e8cc19c082c35e"></a><!-- doxytag: member="tbb::task::recycle_as_child_of" ref="a52ad4704f6241097b1e8cc19c082c35e" args="(task &amp;new_parent)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a52ad4704f6241097b1e8cc19c082c35e">recycle_as_child_of</a> (<a class="el" href="a00144.html">task</a> &amp;new_parent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change this to be a child of new_parent. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a414ac430dfeec4795b781a8d00427c87">recycle_to_reexecute</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Schedule this for reexecution after current <a class="el" href="a00144.html#a092e58368b7684207bd3020c6d104f2a" title="Should be overridden by derived classes.">execute()</a> returns.  <a href="#a414ac430dfeec4795b781a8d00427c87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a172f2c9ac56ed333fd0c41e4c9065cc6"></a><!-- doxytag: member="tbb::task::depth" ref="a172f2c9ac56ed333fd0c41e4c9065cc6" args="() const " -->
intptr_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>depth</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6905bbb1ca0a21ec7d544146dc7d2044"></a><!-- doxytag: member="tbb::task::set_depth" ref="a6905bbb1ca0a21ec7d544146dc7d2044" args="(intptr_t)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>set_depth</b> (intptr_t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af58e689399bc2ebe8e015e7ccf5b1d48"></a><!-- doxytag: member="tbb::task::add_to_depth" ref="af58e689399bc2ebe8e015e7ccf5b1d48" args="(int)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>add_to_depth</b> (int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca4ee1355d9f6acfd34f736fa889f3fd"></a><!-- doxytag: member="tbb::task::set_ref_count" ref="aca4ee1355d9f6acfd34f736fa889f3fd" args="(int count)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#aca4ee1355d9f6acfd34f736fa889f3fd">set_ref_count</a> (int count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set reference count. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#ad073347530703d8ffb98b889a69f0ea4">increment_ref_count</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically increment reference count and returns its old value.  <a href="#ad073347530703d8ffb98b889a69f0ea4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a488d3b726c893e91d8a625caf4cf96f3">decrement_ref_count</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically decrement reference count and returns its new value.  <a href="#a488d3b726c893e91d8a625caf4cf96f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99ea4f316479857b3de302bb0966ef72"></a><!-- doxytag: member="tbb::task::spawn_and_wait_for_all" ref="a99ea4f316479857b3de302bb0966ef72" args="(task &amp;child)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a99ea4f316479857b3de302bb0966ef72">spawn_and_wait_for_all</a> (<a class="el" href="a00144.html">task</a> &amp;child)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to spawn followed by wait_for_all, but more efficient. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4c9763941c0fbd35060a979872bf5e1"></a><!-- doxytag: member="tbb::task::spawn_and_wait_for_all" ref="ad4c9763941c0fbd35060a979872bf5e1" args="(task_list &amp;list)" -->
void __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#ad4c9763941c0fbd35060a979872bf5e1">spawn_and_wait_for_all</a> (<a class="el" href="a00152.html">task_list</a> &amp;list)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to spawn followed by wait_for_all, but more efficient. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#aab6be2d551d52d8d62a92ef87f3ec508">wait_for_all</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for reference count to become one, and set reference count to zero.  <a href="#aab6be2d551d52d8d62a92ef87f3ec508"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d50759d59a2d300287158f38b317798"></a><!-- doxytag: member="tbb::task::parent" ref="a9d50759d59a2d300287158f38b317798" args="() const " -->
<a class="el" href="a00144.html">task</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a9d50759d59a2d300287158f38b317798">parent</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> on whose behalf this <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> is working, or NULL if this is a root. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a537d5c946c6715e0d76974dc53e616bc"></a><!-- doxytag: member="tbb::task::set_parent" ref="a537d5c946c6715e0d76974dc53e616bc" args="(task *p)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a537d5c946c6715e0d76974dc53e616bc">set_parent</a> (<a class="el" href="a00144.html">task</a> *p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets parent <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> pointer to specified value <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00149.html">task_group_context</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#ada4ae99995a8f7b0cf1bbb6febbff8bb">context</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method is deprecated and will be removed in the future.  <a href="#ada4ae99995a8f7b0cf1bbb6febbff8bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a750f29eb8526c15e171c90a7f2962603"></a><!-- doxytag: member="tbb::task::group" ref="a750f29eb8526c15e171c90a7f2962603" args="()" -->
<a class="el" href="a00149.html">task_group_context</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a750f29eb8526c15e171c90a7f2962603">group</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> group descriptor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f1389831c34ae70c07537c1d4fd9ffb"></a><!-- doxytag: member="tbb::task::is_stolen_task" ref="a0f1389831c34ae70c07537c1d4fd9ffb" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a0f1389831c34ae70c07537c1d4fd9ffb">is_stolen_task</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> was stolen from the <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> pool of another thread. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22ef8282e09458a46131843219cb71e5"></a><!-- doxytag: member="tbb::task::state" ref="a22ef8282e09458a46131843219cb71e5" args="() const " -->
<a class="el" href="a00144.html#a3935129602baa0b18727f8fc7384dbf1">state_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a22ef8282e09458a46131843219cb71e5">state</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current execution state. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab82188cc88d0306a706fac651621c4c8"></a><!-- doxytag: member="tbb::task::ref_count" ref="ab82188cc88d0306a706fac651621c4c8" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#ab82188cc88d0306a706fac651621c4c8">ref_count</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The internal reference count. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a5b08efc1c6c413ad224a5d4dba5bc0"></a><!-- doxytag: member="tbb::task::is_owned_by_current_thread" ref="a2a5b08efc1c6c413ad224a5d4dba5bc0" args="() const " -->
bool __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a2a5b08efc1c6c413ad224a5d4dba5bc0">is_owned_by_current_thread</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obsolete, and only retained for the sake of backward compatibility. Always returns true. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9145d7f0f59589ff43db878766abf43"></a><!-- doxytag: member="tbb::task::set_affinity" ref="ab9145d7f0f59589ff43db878766abf43" args="(affinity_id id)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#ab9145d7f0f59589ff43db878766abf43">set_affinity</a> (<a class="el" href="a00144.html#ae40960dfb45c324ce313ace20029c427">affinity_id</a> id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set affinity for this <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa6b377971d086ee8eda49873f87430a"></a><!-- doxytag: member="tbb::task::affinity" ref="afa6b377971d086ee8eda49873f87430a" args="() const " -->
<a class="el" href="a00144.html#ae40960dfb45c324ce313ace20029c427">affinity_id</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#afa6b377971d086ee8eda49873f87430a">affinity</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current affinity of this <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a8b83277e8e5ec5c51d7a0bc654753d7c">note_affinity</a> (<a class="el" href="a00144.html#ae40960dfb45c324ce313ace20029c427">affinity_id</a> id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invoked by scheduler to notify <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> that it ran on unexpected thread.  <a href="#a8b83277e8e5ec5c51d7a0bc654753d7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a08be5c3a725bd39440411aef2a420bf5">change_group</a> (<a class="el" href="a00149.html">task_group_context</a> &amp;ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves this <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> from its current group into another one.  <a href="#a08be5c3a725bd39440411aef2a420bf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a5fb363a9917f1b6b24d3b053e9b5f2a6">cancel_group_execution</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initiates cancellation of all tasks in this cancellation group and its subordinate groups.  <a href="#a5fb363a9917f1b6b24d3b053e9b5f2a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a540796b339aa9e5bd08cad1cc91da84b"></a><!-- doxytag: member="tbb::task::is_cancelled" ref="a540796b339aa9e5bd08cad1cc91da84b" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a540796b339aa9e5bd08cad1cc91da84b">is_cancelled</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the context has received cancellation request. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a540796b339aa9e5bd08cad1cc91da84b"></a><!-- doxytag: member="tbb::task::is_cancelled" ref="a540796b339aa9e5bd08cad1cc91da84b" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>is_cancelled</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1554fbbaf37f47adab31bb8c8ebd047b"></a><!-- doxytag: member="tbb::task::set_group_priority" ref="a1554fbbaf37f47adab31bb8c8ebd047b" args="(priority_t p)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a1554fbbaf37f47adab31bb8c8ebd047b">set_group_priority</a> (priority_t p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes priority of the <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> group this <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> belongs to. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98e779cff1734479d8ad7f732000a165"></a><!-- doxytag: member="tbb::task::group_priority" ref="a98e779cff1734479d8ad7f732000a165" args="() const " -->
priority_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a98e779cff1734479d8ad7f732000a165">group_priority</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves current priority of the <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> group this <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> belongs to. <br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7a9405b422bec9110854acd71edb9f2"></a><!-- doxytag: member="tbb::task::allocate_root" ref="ac7a9405b422bec9110854acd71edb9f2" args="()" -->
static <br class="typebreak"/>
internal::allocate_root_proxy&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#ac7a9405b422bec9110854acd71edb9f2">allocate_root</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns proxy for overloaded new that allocates a root <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae812b7fb5cab409372fe347dbbd38304"></a><!-- doxytag: member="tbb::task::allocate_root" ref="ae812b7fb5cab409372fe347dbbd38304" args="(task_group_context &amp;ctx)" -->
static <br class="typebreak"/>
internal::allocate_root_with_context_proxy&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#ae812b7fb5cab409372fe347dbbd38304">allocate_root</a> (<a class="el" href="a00149.html">task_group_context</a> &amp;ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns proxy for overloaded new that allocates a root <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> associated with user supplied context. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af19c8ef47d1feb6dae459a99efb8bd31"></a><!-- doxytag: member="tbb::task::spawn_root_and_wait" ref="af19c8ef47d1feb6dae459a99efb8bd31" args="(task &amp;root)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#af19c8ef47d1feb6dae459a99efb8bd31">spawn_root_and_wait</a> (<a class="el" href="a00144.html">task</a> &amp;root)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spawn <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> allocated by allocate_root, wait for it to complete, and deallocate it. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a093a4da885180ae584a56fb7c02e4c38">spawn_root_and_wait</a> (<a class="el" href="a00152.html">task_list</a> &amp;root_list)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spawn root tasks on list and wait for all of them to finish.  <a href="#a093a4da885180ae584a56fb7c02e4c38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a391face6a5f6fee8eef31c737106ba7e">enqueue</a> (<a class="el" href="a00144.html">task</a> &amp;t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> for starvation-resistant execution.  <a href="#a391face6a5f6fee8eef31c737106ba7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef93f12f35325660e03b31cabbb01b77"></a><!-- doxytag: member="tbb::task::enqueue" ref="aef93f12f35325660e03b31cabbb01b77" args="(task &amp;t, priority_t p)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#aef93f12f35325660e03b31cabbb01b77">enqueue</a> (<a class="el" href="a00144.html">task</a> &amp;t, priority_t p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> for starvation-resistant execution on the specified priority level. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a898b1552bb4039567e5c1bb2fc3ff943"></a><!-- doxytag: member="tbb::task::self" ref="a898b1552bb4039567e5c1bb2fc3ff943" args="()" -->
static <a class="el" href="a00144.html">task</a> &amp;__TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#a898b1552bb4039567e5c1bb2fc3ff943">self</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The innermost <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> being executed or destroyed by the current thread at the moment. <br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2d9c5ec51ef240a72130480b5a25638"></a><!-- doxytag: member="tbb::task::task" ref="ad2d9c5ec51ef240a72130480b5a25638" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html#ad2d9c5ec51ef240a72130480b5a25638">task</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf87ea5e683e46dd666d260142796961"></a><!-- doxytag: member="tbb::task::interface5::internal::task_base" ref="adf87ea5e683e46dd666d260142796961" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>interface5::internal::task_base</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95a8ebd4b4310ccd0075da4df02103ea"></a><!-- doxytag: member="tbb::task::task_list" ref="a95a8ebd4b4310ccd0075da4df02103ea" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>task_list</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ebef2625215e8ed6836bb15990adce1"></a><!-- doxytag: member="tbb::task::internal::scheduler" ref="a9ebef2625215e8ed6836bb15990adce1" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::scheduler</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac79a9aa664be4320b16a72110ff5c41c"></a><!-- doxytag: member="tbb::task::internal::allocate_root_proxy" ref="ac79a9aa664be4320b16a72110ff5c41c" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::allocate_root_proxy</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26855f4e884eee14d49f2ba7b8cd1dcf"></a><!-- doxytag: member="tbb::task::internal::allocate_root_with_context_proxy" ref="a26855f4e884eee14d49f2ba7b8cd1dcf" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::allocate_root_with_context_proxy</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6315640eb4a3d4ff0bf38d82e855a23d"></a><!-- doxytag: member="tbb::task::internal::allocate_continuation_proxy" ref="a6315640eb4a3d4ff0bf38d82e855a23d" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::allocate_continuation_proxy</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a120ae94a5f72146e3acddd6d782bd176"></a><!-- doxytag: member="tbb::task::internal::allocate_child_proxy" ref="a120ae94a5f72146e3acddd6d782bd176" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::allocate_child_proxy</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3a52fd61beaabc1c6b8ad04284d6925"></a><!-- doxytag: member="tbb::task::internal::allocate_additional_child_of_proxy" ref="af3a52fd61beaabc1c6b8ad04284d6925" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::allocate_additional_child_of_proxy</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Base class for user-defined tasks. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ae40960dfb45c324ce313ace20029c427"></a><!-- doxytag: member="tbb::task::affinity_id" ref="ae40960dfb45c324ce313ace20029c427" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::affinity_id <a class="el" href="a00144.html#ae40960dfb45c324ce313ace20029c427">tbb::task::affinity_id</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An id as used for specifying affinity. </p>
<p>Guaranteed to be integral type. Value of 0 means no affinity. </p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a3935129602baa0b18727f8fc7384dbf1"></a><!-- doxytag: member="tbb::task::state_type" ref="a3935129602baa0b18727f8fc7384dbf1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00144.html#a3935129602baa0b18727f8fc7384dbf1">tbb::task::state_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumeration of <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> states that the scheduler considers. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a3935129602baa0b18727f8fc7384dbf1ae450c433161eef2e97881924b0a5ffba"></a><!-- doxytag: member="executing" ref="a3935129602baa0b18727f8fc7384dbf1ae450c433161eef2e97881924b0a5ffba" args="" -->executing</em>&nbsp;</td><td>
<p><a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> is running, and will be destroyed after method <a class="el" href="a00144.html#a092e58368b7684207bd3020c6d104f2a" title="Should be overridden by derived classes.">execute()</a> completes. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3935129602baa0b18727f8fc7384dbf1aa20ac4d74e3124043471d357d786daf3"></a><!-- doxytag: member="reexecute" ref="a3935129602baa0b18727f8fc7384dbf1aa20ac4d74e3124043471d357d786daf3" args="" -->reexecute</em>&nbsp;</td><td>
<p><a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> to be rescheduled. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3935129602baa0b18727f8fc7384dbf1ab2cde487a169988d66fc1052cedc92dc"></a><!-- doxytag: member="ready" ref="a3935129602baa0b18727f8fc7384dbf1ab2cde487a169988d66fc1052cedc92dc" args="" -->ready</em>&nbsp;</td><td>
<p><a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> is in ready pool, or is going to be put there, or was just taken off. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3935129602baa0b18727f8fc7384dbf1a8d74b73d7ceaf5341c9c2552d6c68084"></a><!-- doxytag: member="allocated" ref="a3935129602baa0b18727f8fc7384dbf1a8d74b73d7ceaf5341c9c2552d6c68084" args="" -->allocated</em>&nbsp;</td><td>
<p><a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> object is freshly allocated or recycled. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3935129602baa0b18727f8fc7384dbf1ad5877992ceab99813e0aa790420504de"></a><!-- doxytag: member="freed" ref="a3935129602baa0b18727f8fc7384dbf1ad5877992ceab99813e0aa790420504de" args="" -->freed</em>&nbsp;</td><td>
<p><a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> object is on free list, or is going to be put there, or was just taken off. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3935129602baa0b18727f8fc7384dbf1a0e8b8338e4fd9cf8928be788540f878b"></a><!-- doxytag: member="recycle" ref="a3935129602baa0b18727f8fc7384dbf1a0e8b8338e4fd9cf8928be788540f878b" args="" -->recycle</em>&nbsp;</td><td>
<p><a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> to be recycled as continuation </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a3d541e86f39624d4cb8f8c90a39e57f9"></a><!-- doxytag: member="tbb::task::allocate_continuation" ref="a3d541e86f39624d4cb8f8c90a39e57f9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::allocate_continuation_proxy&amp; tbb::task::allocate_continuation </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns proxy for overloaded new that allocates a continuation <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> of *this. </p>
<p>The continuation's parent becomes the parent of *this. </p>

</div>
</div>
<a class="anchor" id="a5fb363a9917f1b6b24d3b053e9b5f2a6"></a><!-- doxytag: member="tbb::task::cancel_group_execution" ref="a5fb363a9917f1b6b24d3b053e9b5f2a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tbb::task::cancel_group_execution </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initiates cancellation of all tasks in this cancellation group and its subordinate groups. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if cancellation has already been requested, true otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a08be5c3a725bd39440411aef2a420bf5"></a><!-- doxytag: member="tbb::task::change_group" ref="a08be5c3a725bd39440411aef2a420bf5" args="(task_group_context &amp;ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __TBB_EXPORTED_METHOD tbb::task::change_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00149.html">task_group_context</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ctx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves this <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> from its current group into another one. </p>
<p>Argument ctx specifies the new group.</p>
<p>The primary purpose of this method is to associate unique <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> group context with a <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> allocated for subsequent enqueuing. In contrast to spawned tasks enqueued ones normally outlive the scope where they were created. This makes traditional usage model where <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> group context are allocated locally on the stack inapplicable. Dynamic allocation of context objects is performance inefficient. Method <a class="el" href="a00144.html#a08be5c3a725bd39440411aef2a420bf5" title="Moves this task from its current group into another one.">change_group()</a> allows to make <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> group context object a member of the <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> class, and then associate it with its containing <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> object in the latter's constructor. </p>

</div>
</div>
<a class="anchor" id="ada4ae99995a8f7b0cf1bbb6febbff8bb"></a><!-- doxytag: member="tbb::task::context" ref="ada4ae99995a8f7b0cf1bbb6febbff8bb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00149.html">task_group_context</a>* tbb::task::context </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method is deprecated and will be removed in the future. </p>
<p>Use method <a class="el" href="a00144.html#a750f29eb8526c15e171c90a7f2962603" title="Pointer to the task group descriptor.">group()</a> instead. </p>

<p>Referenced by <a class="el" href="a00216_source.html#l00622">recycle_as_child_of()</a>.</p>

</div>
</div>
<a class="anchor" id="a488d3b726c893e91d8a625caf4cf96f3"></a><!-- doxytag: member="tbb::task::decrement_ref_count" ref="a488d3b726c893e91d8a625caf4cf96f3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tbb::task::decrement_ref_count </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically decrement reference count and returns its new value. </p>
<p>Has release semantics. </p>

<p>Referenced by <a class="el" href="a00193_source.html#l00413">tbb::flow::interface6::graph::decrement_wait_count()</a>.</p>

</div>
</div>
<a class="anchor" id="a1080aedc3bcbbcfa8c7c894d9d477ee6"></a><!-- doxytag: member="tbb::task::destroy" ref="a1080aedc3bcbbcfa8c7c894d9d477ee6" args="(task &amp;t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __TBB_EXPORTED_METHOD tbb::task::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00144.html">task</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a>. </p>
<p>Usually, calling this method is unnecessary, because a <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> is implicitly deleted after its <a class="el" href="a00144.html#a092e58368b7684207bd3020c6d104f2a" title="Should be overridden by derived classes.">execute()</a> method runs. However, sometimes a <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> needs to be explicitly deallocated, such as when a root <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> is used as the parent in spawn_and_wait_for_all. </p>

<p>Referenced by <a class="el" href="a00205_source.html#l00171">tbb::parallel_while&lt; Body &gt;::run()</a>, <a class="el" href="a00193_source.html#l00395">tbb::flow::interface6::graph::~graph()</a>, and <a class="el" href="a00205_source.html#l00143">tbb::parallel_while&lt; Body &gt;::~parallel_while()</a>.</p>

</div>
</div>
<a class="anchor" id="a391face6a5f6fee8eef31c737106ba7e"></a><!-- doxytag: member="tbb::task::enqueue" ref="a391face6a5f6fee8eef31c737106ba7e" args="(task &amp;t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void tbb::task::enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00144.html">task</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueue <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> for starvation-resistant execution. </p>
<p>The <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> will be enqueued on the normal priority level disregarding the priority of its <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> group.</p>
<p>The rationale of such semantics is that priority of an enqueued <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> is statically fixed at the moment of its enqueuing, while <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> group priority is dynamic. Thus automatic priority inheritance would be generally a subject to the race, which may result in unexpected behavior.</p>
<p>Use <a class="el" href="a00144.html#a391face6a5f6fee8eef31c737106ba7e" title="Enqueue task for starvation-resistant execution.">enqueue()</a> overload with explicit priority value and <a class="el" href="a00144.html#a98e779cff1734479d8ad7f732000a165" title="Retrieves current priority of the task group this task belongs to.">task::group_priority()</a> method to implement such priority inheritance when it is really necessary. </p>

<p>Referenced by <a class="el" href="a00193_source.html#l01857">tbb::flow::interface6::limiter_node&lt; T &gt;::register_predecessor()</a>, <a class="el" href="a00193_source.html#l00422">tbb::flow::interface6::graph::run()</a>, and <a class="el" href="a00193_source.html#l00157">tbb::flow::interface6::receiver&lt; continue_msg &gt;::try_put()</a>.</p>

</div>
</div>
<a class="anchor" id="ad073347530703d8ffb98b889a69f0ea4"></a><!-- doxytag: member="tbb::task::increment_ref_count" ref="ad073347530703d8ffb98b889a69f0ea4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbb::task::increment_ref_count </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically increment reference count and returns its old value. </p>
<p>Has acquire semantics </p>

<p>Referenced by <a class="el" href="a00193_source.html#l00405">tbb::flow::interface6::graph::increment_wait_count()</a>.</p>

</div>
</div>
<a class="anchor" id="a8b83277e8e5ec5c51d7a0bc654753d7c"></a><!-- doxytag: member="tbb::task::note_affinity" ref="a8b83277e8e5ec5c51d7a0bc654753d7c" args="(affinity_id id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void __TBB_EXPORTED_METHOD tbb::task::note_affinity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00144.html#ae40960dfb45c324ce313ace20029c427">affinity_id</a>&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Invoked by scheduler to notify <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> that it ran on unexpected thread. </p>
<p>Invoked before method <a class="el" href="a00144.html#a092e58368b7684207bd3020c6d104f2a" title="Should be overridden by derived classes.">execute()</a> runs, if <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> is stolen, or <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> has affinity but will be executed on another thread.</p>
<p>The default action does nothing. </p>

</div>
</div>
<a class="anchor" id="a725edf7e253dfd8fb47638b31e3be898"></a><!-- doxytag: member="tbb::task::recycle_as_continuation" ref="a725edf7e253dfd8fb47638b31e3be898" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbb::task::recycle_as_continuation </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change this to be a continuation of its former self. </p>
<p>The caller must guarantee that the task's refcount does not become zero until after the method <a class="el" href="a00144.html#a092e58368b7684207bd3020c6d104f2a" title="Should be overridden by derived classes.">execute()</a> returns. Typically, this is done by having method <a class="el" href="a00144.html#a092e58368b7684207bd3020c6d104f2a" title="Should be overridden by derived classes.">execute()</a> return a pointer to a child of the <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a>. If the guarantee cannot be made, use method recycle_as_safe_continuation instead.</p>
<p>Because of the hazard, this method may be deprecated in the future. </p>

</div>
</div>
<a class="anchor" id="ab095026979917d405f7bff17f3c4b482"></a><!-- doxytag: member="tbb::task::recycle_as_safe_continuation" ref="ab095026979917d405f7bff17f3c4b482" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbb::task::recycle_as_safe_continuation </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recommended to use, safe variant of recycle_as_continuation. </p>
<p>For safety, it requires additional increment of ref_count. With no descendants and ref_count of 1, it has the semantics of recycle_to_reexecute. </p>

</div>
</div>
<a class="anchor" id="a414ac430dfeec4795b781a8d00427c87"></a><!-- doxytag: member="tbb::task::recycle_to_reexecute" ref="a414ac430dfeec4795b781a8d00427c87" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbb::task::recycle_to_reexecute </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedule this for reexecution after current <a class="el" href="a00144.html#a092e58368b7684207bd3020c6d104f2a" title="Should be overridden by derived classes.">execute()</a> returns. </p>
<p>Made obsolete by recycle_as_safe_continuation; may become deprecated. </p>

</div>
</div>
<a class="anchor" id="a093a4da885180ae584a56fb7c02e4c38"></a><!-- doxytag: member="tbb::task::spawn_root_and_wait" ref="a093a4da885180ae584a56fb7c02e4c38" args="(task_list &amp;root_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbb::task::spawn_root_and_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00152.html">task_list</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>root_list</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Spawn root tasks on list and wait for all of them to finish. </p>
<p>If there are more tasks than worker threads, the tasks are spawned in order of front to back. </p>

<p>References <a class="el" href="a00216_source.html#l00896">tbb::task_list::clear()</a>.</p>

</div>
</div>
<a class="anchor" id="aab6be2d551d52d8d62a92ef87f3ec508"></a><!-- doxytag: member="tbb::task::wait_for_all" ref="aab6be2d551d52d8d62a92ef87f3ec508" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbb::task::wait_for_all </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for reference count to become one, and set reference count to zero. </p>
<p>Works on tasks while waiting. </p>

<p>Referenced by <a class="el" href="a00193_source.html#l00438">tbb::flow::interface6::graph::wait_for_all()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00216_source.html">task.h</a></li>
</ul>
</div>
<hr>
<p></p>
Copyright &copy; 2005-2013 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
