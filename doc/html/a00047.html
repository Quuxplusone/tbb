<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>tbb::concurrent_vector&lt; T, A &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="a00236.html">tbb</a>::<a class="el" href="a00047.html">concurrent_vector</a>
  </div>
</div>
<div class="contents">
<h1>tbb::concurrent_vector&lt; T, A &gt; Class Template Reference<br/>
<small>
[<a class="el" href="a00250.html">Containers</a>]</small>
</h1><!-- doxytag: class="tbb::concurrent_vector" -->
<p><code>#include &lt;<a class="el" href="a00190_source.html">concurrent_vector.h</a>&gt;</code></p>

<p><a href="a00272.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>generic_range_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>internal_loop_guide</b></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception-aware helper class for filling a segment by exception-danger operators of user class. <br/></td></tr>
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada098ff121699bfed7ae37e759eff93d"></a><!-- doxytag: member="tbb::concurrent_vector::size_type" ref="ada098ff121699bfed7ae37e759eff93d" args="" -->
typedef <br class="typebreak"/>
internal::concurrent_vector_base_v3::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7560567b5735c57159e55b12d20b6710"></a><!-- doxytag: member="tbb::concurrent_vector::allocator_type" ref="a7560567b5735c57159e55b12d20b6710" args="" -->
typedef <br class="typebreak"/>
internal::allocator_base&lt; T, A &gt;<br class="typebreak"/>
::allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5cf801a503d4e5fe739f53d7321dd2ef"></a><!-- doxytag: member="tbb::concurrent_vector::value_type" ref="a5cf801a503d4e5fe739f53d7321dd2ef" args="" -->
typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bb52adb877d3b680dac5f0bd289700b"></a><!-- doxytag: member="tbb::concurrent_vector::difference_type" ref="a1bb52adb877d3b680dac5f0bd289700b" args="" -->
typedef ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a412441e93ad8656f96b14c5ecb9d817f"></a><!-- doxytag: member="tbb::concurrent_vector::reference" ref="a412441e93ad8656f96b14c5ecb9d817f" args="" -->
typedef T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ecbb1eb2c7264df9d58255ce211207c"></a><!-- doxytag: member="tbb::concurrent_vector::const_reference" ref="a5ecbb1eb2c7264df9d58255ce211207c" args="" -->
typedef const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2c4f00678df69d2d11497e8dd6ed9cf"></a><!-- doxytag: member="tbb::concurrent_vector::pointer" ref="aa2c4f00678df69d2d11497e8dd6ed9cf" args="" -->
typedef T *&nbsp;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa0d28eb686589cbaf4733ca0eabc071"></a><!-- doxytag: member="tbb::concurrent_vector::const_pointer" ref="afa0d28eb686589cbaf4733ca0eabc071" args="" -->
typedef const T *&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cee8eaee236867c0b6e87309380cb0f"></a><!-- doxytag: member="tbb::concurrent_vector::iterator" ref="a4cee8eaee236867c0b6e87309380cb0f" args="" -->
typedef <br class="typebreak"/>
internal::vector_iterator<br class="typebreak"/>
&lt; <a class="el" href="a00047.html">concurrent_vector</a>, T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9a55035528c055ae985db2a61c8b0b2"></a><!-- doxytag: member="tbb::concurrent_vector::const_iterator" ref="aa9a55035528c055ae985db2a61c8b0b2" args="" -->
typedef <br class="typebreak"/>
internal::vector_iterator<br class="typebreak"/>
&lt; <a class="el" href="a00047.html">concurrent_vector</a>, const T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1623110816f9ef8f08e7bf6768aed273"></a><!-- doxytag: member="tbb::concurrent_vector::reverse_iterator" ref="a1623110816f9ef8f08e7bf6768aed273" args="" -->
typedef std::reverse_iterator<br class="typebreak"/>
&lt; iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada43b048144c3814036da624d3bb8c58"></a><!-- doxytag: member="tbb::concurrent_vector::const_reverse_iterator" ref="ada43b048144c3814036da624d3bb8c58" args="" -->
typedef std::reverse_iterator<br class="typebreak"/>
&lt; const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbeeef740ea402fa136ca3962fc0c307"></a><!-- doxytag: member="tbb::concurrent_vector::reverse_iterator" ref="adbeeef740ea402fa136ca3962fc0c307" args="" -->
typedef std::reverse_iterator<br class="typebreak"/>
&lt; iterator, T, T &amp;, T * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a705a54ffc90b914fc9c30d4177e8228a"></a><!-- doxytag: member="tbb::concurrent_vector::const_reverse_iterator" ref="a705a54ffc90b914fc9c30d4177e8228a" args="" -->
typedef std::reverse_iterator<br class="typebreak"/>
&lt; const_iterator, T, const T <br class="typebreak"/>
&amp;, const T * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a443492ee9918c9e3372b5daca82314ca"></a><!-- doxytag: member="tbb::concurrent_vector::range_type" ref="a443492ee9918c9e3372b5daca82314ca" args="" -->
typedef generic_range_type<br class="typebreak"/>
&lt; iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>range_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1312eb29abf7ca07aa365c727b7844e3"></a><!-- doxytag: member="tbb::concurrent_vector::const_range_type" ref="a1312eb29abf7ca07aa365c727b7844e3" args="" -->
typedef generic_range_type<br class="typebreak"/>
&lt; const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_range_type</b></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bd95c2241653c760704a92b2c887a48"></a><!-- doxytag: member="tbb::concurrent_vector::concurrent_vector" ref="a5bd95c2241653c760704a92b2c887a48" args="(const allocator_type &amp;a=allocator_type())" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a5bd95c2241653c760704a92b2c887a48">concurrent_vector</a> (const allocator_type &amp;a=allocator_type())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct empty vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa25dccd2f65fbfa148e92d01a11c20ff"></a><!-- doxytag: member="tbb::concurrent_vector::concurrent_vector" ref="aa25dccd2f65fbfa148e92d01a11c20ff" args="(std::initializer_list&lt; T &gt; init_list, const allocator_type &amp;a=allocator_type())" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#aa25dccd2f65fbfa148e92d01a11c20ff">concurrent_vector</a> (std::initializer_list&lt; T &gt; init_list, const allocator_type &amp;a=allocator_type())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor from initializer_list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03b5a0e9069b30dc4e2e5fc2f191ccb6"></a><!-- doxytag: member="tbb::concurrent_vector::concurrent_vector" ref="a03b5a0e9069b30dc4e2e5fc2f191ccb6" args="(const concurrent_vector &amp;vector, const allocator_type &amp;a=allocator_type())" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a03b5a0e9069b30dc4e2e5fc2f191ccb6">concurrent_vector</a> (const <a class="el" href="a00047.html">concurrent_vector</a> &amp;vector, const allocator_type &amp;a=allocator_type())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copying constructor. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a105e641efaa5006ba99be386603c1671"></a><!-- doxytag: member="tbb::concurrent_vector::concurrent_vector" ref="a105e641efaa5006ba99be386603c1671" args="(const concurrent_vector&lt; T, M &gt; &amp;vector, const allocator_type &amp;a=allocator_type())" -->
template&lt;class M &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00047.html#a105e641efaa5006ba99be386603c1671">concurrent_vector</a> (const <a class="el" href="a00047.html">concurrent_vector</a>&lt; T, M &gt; &amp;vector, const allocator_type &amp;a=allocator_type())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copying constructor for vector with different allocator type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa898a39aad73711ceca70cd465dc0b4f"></a><!-- doxytag: member="tbb::concurrent_vector::concurrent_vector" ref="aa898a39aad73711ceca70cd465dc0b4f" args="(size_type n)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#aa898a39aad73711ceca70cd465dc0b4f">concurrent_vector</a> (size_type n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construction with initial size specified by argument n. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a736c6e35f1df11625636968ea546e21f"></a><!-- doxytag: member="tbb::concurrent_vector::concurrent_vector" ref="a736c6e35f1df11625636968ea546e21f" args="(size_type n, const_reference t, const allocator_type &amp;a=allocator_type())" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a736c6e35f1df11625636968ea546e21f">concurrent_vector</a> (size_type n, const_reference t, const allocator_type &amp;a=allocator_type())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construction with initial size specified by argument n, initialization by copying of t, and given allocator instance. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a28bb70c6bcb0a7501f2b3619d8a0e5df"></a><!-- doxytag: member="tbb::concurrent_vector::concurrent_vector" ref="a28bb70c6bcb0a7501f2b3619d8a0e5df" args="(I first, I last, const allocator_type &amp;a=allocator_type())" -->
template&lt;class I &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00047.html#a28bb70c6bcb0a7501f2b3619d8a0e5df">concurrent_vector</a> (I first, I last, const allocator_type &amp;a=allocator_type())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construction with copying iteration range and given allocator instance. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a920384aece0eb8beea3049956320ec91"></a><!-- doxytag: member="tbb::concurrent_vector::operator=" ref="a920384aece0eb8beea3049956320ec91" args="(const concurrent_vector &amp;vector)" -->
<a class="el" href="a00047.html">concurrent_vector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a920384aece0eb8beea3049956320ec91">operator=</a> (const <a class="el" href="a00047.html">concurrent_vector</a> &amp;vector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5824bd1f8b620ac8484e0a34fd8948d2"></a><!-- doxytag: member="tbb::concurrent_vector::operator=" ref="a5824bd1f8b620ac8484e0a34fd8948d2" args="(const concurrent_vector&lt; T, M &gt; &amp;vector)" -->
template&lt;class M &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00047.html">concurrent_vector</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00047.html#a5824bd1f8b620ac8484e0a34fd8948d2">operator=</a> (const <a class="el" href="a00047.html">concurrent_vector</a>&lt; T, M &gt; &amp;vector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment for vector with different allocator type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e57d73b199ccd03922898e9da4888fb"></a><!-- doxytag: member="tbb::concurrent_vector::operator=" ref="a6e57d73b199ccd03922898e9da4888fb" args="(const std::initializer_list&lt; T &gt; &amp;init_list)" -->
<a class="el" href="a00047.html">concurrent_vector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a6e57d73b199ccd03922898e9da4888fb">operator=</a> (const std::initializer_list&lt; T &gt; &amp;init_list)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment for initializer_list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a9c8452b88bc79c3c88d47c455064c012">grow_by</a> (size_type delta)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grow by "delta" elements.  <a href="#a9c8452b88bc79c3c88d47c455064c012"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ab89c2db5358048debdc282ff995caffb">grow_by</a> (size_type delta)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a9dae5d9368fd852426552b21d67beb86">grow_by</a> (size_type delta, const_reference t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grow by "delta" elements using copying constructor.  <a href="#a9dae5d9368fd852426552b21d67beb86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#aa11fc991cda82cf93789fce31b37a16c">grow_by</a> (size_type delta, const_reference t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#af52b603dd76a99dffe5760f0db4747f1">grow_to_at_least</a> (size_type n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append minimal sequence of elements such that <a class="el" href="a00047.html#a803268c16e3688ff4681251947d257c7" title="Return size of vector. It may include elements under construction.">size()</a>&gt;=n.  <a href="#af52b603dd76a99dffe5760f0db4747f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ae9ef9895e88f9bf036b379035c18f035">grow_to_at_least</a> (size_type n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a4a5c85a9e6ff82e15c18da47a95b518f">push_back</a> (const_reference item) iterator push_back(const _reference item)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Push item.  <a href="#a4a5c85a9e6ff82e15c18da47a95b518f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a3097cb46511504acfc9de7da5235f4a6">operator[]</a> (size_type index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get reference to element at given index.  <a href="#a3097cb46511504acfc9de7da5235f4a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd6ca67f2f97fafca48395af2e693e73"></a><!-- doxytag: member="tbb::concurrent_vector::operator[]" ref="abd6ca67f2f97fafca48395af2e693e73" args="(size_type index) const " -->
const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#abd6ca67f2f97fafca48395af2e693e73">operator[]</a> (size_type index) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get const reference to element at given index. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a629a29eb21e528414b9d5c9becfe05cd"></a><!-- doxytag: member="tbb::concurrent_vector::at" ref="a629a29eb21e528414b9d5c9becfe05cd" args="(size_type index)" -->
reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a629a29eb21e528414b9d5c9becfe05cd">at</a> (size_type index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get reference to element at given index. Throws exceptions on errors. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4dc6c1b55c0e0b73f0a8675ef2b60a4"></a><!-- doxytag: member="tbb::concurrent_vector::at" ref="ae4dc6c1b55c0e0b73f0a8675ef2b60a4" args="(size_type index) const " -->
const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ae4dc6c1b55c0e0b73f0a8675ef2b60a4">at</a> (size_type index) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get const reference to element at given index. Throws exceptions on errors. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8201f65735edcc28aeec95b6e73d75b6"></a><!-- doxytag: member="tbb::concurrent_vector::range" ref="a8201f65735edcc28aeec95b6e73d75b6" args="(size_t grainsize=1)" -->
range_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a8201f65735edcc28aeec95b6e73d75b6">range</a> (size_t grainsize=1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get range for iterating with parallel algorithms. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fcc32ec9ccb48c3327a88fe288c7538"></a><!-- doxytag: member="tbb::concurrent_vector::range" ref="a8fcc32ec9ccb48c3327a88fe288c7538" args="(size_t grainsize=1) const " -->
const_range_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a8fcc32ec9ccb48c3327a88fe288c7538">range</a> (size_t grainsize=1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get const range for iterating with parallel algorithms. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a803268c16e3688ff4681251947d257c7"></a><!-- doxytag: member="tbb::concurrent_vector::size" ref="a803268c16e3688ff4681251947d257c7" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a803268c16e3688ff4681251947d257c7">size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return size of vector. It may include elements under construction. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3f6774107e65642f73c0dcc9a962fe7"></a><!-- doxytag: member="tbb::concurrent_vector::empty" ref="aa3f6774107e65642f73c0dcc9a962fe7" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#aa3f6774107e65642f73c0dcc9a962fe7">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return false if vector is not empty or has elements under construction at least. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96c2ae9dfedc24d62554feb627df76c3"></a><!-- doxytag: member="tbb::concurrent_vector::capacity" ref="a96c2ae9dfedc24d62554feb627df76c3" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a96c2ae9dfedc24d62554feb627df76c3">capacity</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum size to which array can grow without allocating more memory. Concurrent allocations are not included in the value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a0b3284684328c58c0228c9a697ef3594">reserve</a> (size_type n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate enough space to grow to size n without having to allocate more memory later.  <a href="#a0b3284684328c58c0228c9a697ef3594"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65e53a98a1e1fdb515fdc2b84e2314e8"></a><!-- doxytag: member="tbb::concurrent_vector::resize" ref="a65e53a98a1e1fdb515fdc2b84e2314e8" args="(size_type n)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a65e53a98a1e1fdb515fdc2b84e2314e8">resize</a> (size_type n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize the vector. Not thread-safe. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a941917a8a840ff08ce8810ca9476ff46"></a><!-- doxytag: member="tbb::concurrent_vector::resize" ref="a941917a8a840ff08ce8810ca9476ff46" args="(size_type n, const_reference t)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a941917a8a840ff08ce8810ca9476ff46">resize</a> (size_type n, const_reference t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize the vector, copy t for new elements. Not thread-safe. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2101247808fd0e81b992724e317a7f3"></a><!-- doxytag: member="tbb::concurrent_vector::compact" ref="af2101247808fd0e81b992724e317a7f3" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#af2101247808fd0e81b992724e317a7f3">compact</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An alias for <a class="el" href="a00047.html#aba805b5225ad3399550f78ea15e51e93" title="Optimize memory usage and fragmentation.">shrink_to_fit()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba805b5225ad3399550f78ea15e51e93"></a><!-- doxytag: member="tbb::concurrent_vector::shrink_to_fit" ref="aba805b5225ad3399550f78ea15e51e93" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#aba805b5225ad3399550f78ea15e51e93">shrink_to_fit</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optimize memory usage and fragmentation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ec9c3ab3360e04bdaa5174956a3206d"></a><!-- doxytag: member="tbb::concurrent_vector::max_size" ref="a0ec9c3ab3360e04bdaa5174956a3206d" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a0ec9c3ab3360e04bdaa5174956a3206d">max_size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Upper bound on argument to reserve. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab55636c80368ad7d400f3200313fcf5f"></a><!-- doxytag: member="tbb::concurrent_vector::begin" ref="ab55636c80368ad7d400f3200313fcf5f" args="()" -->
iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ab55636c80368ad7d400f3200313fcf5f">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">start iterator <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad2c07653375e4a5f89c33b375eda610"></a><!-- doxytag: member="tbb::concurrent_vector::end" ref="aad2c07653375e4a5f89c33b375eda610" args="()" -->
iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#aad2c07653375e4a5f89c33b375eda610">end</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">end iterator <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3eb33d1b10a988a87cc708ceb08f3a9"></a><!-- doxytag: member="tbb::concurrent_vector::begin" ref="ad3eb33d1b10a988a87cc708ceb08f3a9" args="() const " -->
const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ad3eb33d1b10a988a87cc708ceb08f3a9">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">start const iterator <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a4ad0795a19d94df24595e748f0b193"></a><!-- doxytag: member="tbb::concurrent_vector::end" ref="a6a4ad0795a19d94df24595e748f0b193" args="() const " -->
const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a6a4ad0795a19d94df24595e748f0b193">end</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">end const iterator <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a1c5441fa480c07ef37d9206b6260cc"></a><!-- doxytag: member="tbb::concurrent_vector::cbegin" ref="a7a1c5441fa480c07ef37d9206b6260cc" args="() const " -->
const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a7a1c5441fa480c07ef37d9206b6260cc">cbegin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">start const iterator <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ea80faf139feb54d6576c036e4ba898"></a><!-- doxytag: member="tbb::concurrent_vector::cend" ref="a9ea80faf139feb54d6576c036e4ba898" args="() const " -->
const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a9ea80faf139feb54d6576c036e4ba898">cend</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">end const iterator <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a2f8dce0adcbef8e29273c23723a78e"></a><!-- doxytag: member="tbb::concurrent_vector::rbegin" ref="a9a2f8dce0adcbef8e29273c23723a78e" args="()" -->
reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a9a2f8dce0adcbef8e29273c23723a78e">rbegin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reverse start iterator <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a618f38279a370c18f73ea2c29ded9cb9"></a><!-- doxytag: member="tbb::concurrent_vector::rend" ref="a618f38279a370c18f73ea2c29ded9cb9" args="()" -->
reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a618f38279a370c18f73ea2c29ded9cb9">rend</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reverse end iterator <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a976b0bed19de9ab93f78c10184a4e38f"></a><!-- doxytag: member="tbb::concurrent_vector::rbegin" ref="a976b0bed19de9ab93f78c10184a4e38f" args="() const " -->
const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a976b0bed19de9ab93f78c10184a4e38f">rbegin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reverse start const iterator <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdb98e17cb65d9c445d7fd1e662c2699"></a><!-- doxytag: member="tbb::concurrent_vector::rend" ref="abdb98e17cb65d9c445d7fd1e662c2699" args="() const " -->
const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#abdb98e17cb65d9c445d7fd1e662c2699">rend</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reverse end const iterator <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2627db4a7949522ea4727320b23a6348"></a><!-- doxytag: member="tbb::concurrent_vector::crbegin" ref="a2627db4a7949522ea4727320b23a6348" args="() const " -->
const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a2627db4a7949522ea4727320b23a6348">crbegin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reverse start const iterator <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad097225c529dbb24cc0e13a444ab4752"></a><!-- doxytag: member="tbb::concurrent_vector::crend" ref="ad097225c529dbb24cc0e13a444ab4752" args="() const " -->
const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ad097225c529dbb24cc0e13a444ab4752">crend</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reverse end const iterator <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bfc6d733cf543280b691ed8d7b7908a"></a><!-- doxytag: member="tbb::concurrent_vector::front" ref="a9bfc6d733cf543280b691ed8d7b7908a" args="()" -->
reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a9bfc6d733cf543280b691ed8d7b7908a">front</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the first item <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9067259572c2c41d014840d0f9d3cdce"></a><!-- doxytag: member="tbb::concurrent_vector::front" ref="a9067259572c2c41d014840d0f9d3cdce" args="() const " -->
const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a9067259572c2c41d014840d0f9d3cdce">front</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the first item const <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaee3ddf1d05238a8a6887f6d824b76f8"></a><!-- doxytag: member="tbb::concurrent_vector::back" ref="aaee3ddf1d05238a8a6887f6d824b76f8" args="()" -->
reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#aaee3ddf1d05238a8a6887f6d824b76f8">back</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the last item <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf66eb1e82dbcb430d9926a23711c720"></a><!-- doxytag: member="tbb::concurrent_vector::back" ref="acf66eb1e82dbcb430d9926a23711c720" args="() const " -->
const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#acf66eb1e82dbcb430d9926a23711c720">back</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the last item const <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88b62a9614d3f2b59c9c7c1a2143fb1e"></a><!-- doxytag: member="tbb::concurrent_vector::get_allocator" ref="a88b62a9614d3f2b59c9c7c1a2143fb1e" args="() const " -->
allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a88b62a9614d3f2b59c9c7c1a2143fb1e">get_allocator</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return allocator object <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87355dce93d0882aa73333a35c9b367c"></a><!-- doxytag: member="tbb::concurrent_vector::assign" ref="a87355dce93d0882aa73333a35c9b367c" args="(size_type n, const_reference t)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a87355dce93d0882aa73333a35c9b367c">assign</a> (size_type n, const_reference t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">assign n items by copying t item <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af9a33269e755fbf44de1904d5cf717fb"></a><!-- doxytag: member="tbb::concurrent_vector::assign" ref="af9a33269e755fbf44de1904d5cf717fb" args="(I first, I last)" -->
template&lt;class I &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00047.html#af9a33269e755fbf44de1904d5cf717fb">assign</a> (I first, I last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">assign range [first, last) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a584d6cda5794441b19d4f02bde399dff"></a><!-- doxytag: member="tbb::concurrent_vector::assign" ref="a584d6cda5794441b19d4f02bde399dff" args="(std::initializer_list&lt; T &gt; init_list)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a584d6cda5794441b19d4f02bde399dff">assign</a> (std::initializer_list&lt; T &gt; init_list)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">assigns an initializer list <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8603bd57324fb6b60ba006884c95279d"></a><!-- doxytag: member="tbb::concurrent_vector::swap" ref="a8603bd57324fb6b60ba006884c95279d" args="(concurrent_vector &amp;vector)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a8603bd57324fb6b60ba006884c95279d">swap</a> (<a class="el" href="a00047.html">concurrent_vector</a> &amp;vector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">swap two instances <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#a526ba408fb3064ef846940d633b8f365">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear container while keeping memory allocated.  <a href="#a526ba408fb3064ef846940d633b8f365"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5bcaededc9a00e7aaecd6c262fd0b38"></a><!-- doxytag: member="tbb::concurrent_vector::~concurrent_vector" ref="ab5bcaededc9a00e7aaecd6c262fd0b38" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html#ab5bcaededc9a00e7aaecd6c262fd0b38">~concurrent_vector</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear and destroy vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a675f1b62a651d350eb0d778a271e31e5"></a><!-- doxytag: member="tbb::concurrent_vector::internal_vector_base" ref="a675f1b62a651d350eb0d778a271e31e5" args="() const " -->
const <br class="typebreak"/>
internal::concurrent_vector_base_v3 &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal_vector_base</b> () const </td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ca283c26ad36cb052e4d9de968e03ad"></a><!-- doxytag: member="tbb::concurrent_vector::internal::vector_iterator" ref="a3ca283c26ad36cb052e4d9de968e03ad" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::vector_iterator</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename T, class A&gt;<br/>
 class tbb::concurrent_vector&lt; T, A &gt;</h3>

<p>Concurrent vector container <a class="el" href="a00047.html">concurrent_vector</a> is a container having the following main properties:</p>
<ul>
<li>It provides random indexed access to its elements. The index of the first element is 0.</li>
<li>It ensures safe concurrent growing its size (different threads can safely append new elements).</li>
<li>Adding new elements does not invalidate existing iterators and does not change indices of existing items.</li>
</ul>
<dl class="user"><dt><b>Compatibility</b></dt><dd>The class meets all Container Requirements and Reversible Container Requirements from C++ Standard (See ISO/IEC 14882:2003(E), clause 23.1). But it doesn't meet Sequence Requirements due to absence of insert() and erase() methods.</dd></dl>
<dl class="user"><dt><b>Exception Safety</b></dt><dd>Methods working with memory allocation and/or new elements construction can throw an exception if allocator fails to allocate memory or element's default constructor throws one. Concurrent vector's element of type T must conform to the following requirements:<ul>
<li>Throwing an exception is forbidden for destructor of T.</li>
<li>Default constructor of T must not throw an exception OR its non-virtual destructor must safely work when its object memory is zero-initialized.</li>
</ul>
Otherwise, the program's behavior is undefined. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If an exception happens inside growth or assignment operation, an instance of the vector becomes invalid unless it is stated otherwise in the method documentation. Invalid state means:<ul>
<li>There are no guarantees that all items were initialized by a constructor. The rest of items is zero-filled, including item where exception happens.</li>
<li>An invalid vector instance cannot be repaired; it is unable to grow anymore.</li>
<li>Size and capacity reported by the vector are incorrect, and calculated as if the failed operation were successful.</li>
<li>Attempt to access not allocated elements using operator[] or iterators results in access violation or segmentation fault exception, and in case of using <a class="el" href="a00047.html#a629a29eb21e528414b9d5c9becfe05cd" title="Get reference to element at given index. Throws exceptions on errors.">at()</a> method a C++ exception is thrown.</li>
</ul>
If a concurrent grow operation successfully completes, all the elements it has added to the vector will remain valid and accessible even if one of subsequent grow operations fails.</dd></dl>
<dl class="user"><dt><b>Fragmentation</b></dt><dd>Unlike an STL vector, a <a class="el" href="a00047.html">concurrent_vector</a> does not move existing elements if it needs to allocate more memory. The container is divided into a series of contiguous arrays of elements. The first reservation, growth, or assignment operation determines the size of the first array. Using small number of elements as initial size incurs fragmentation that may increase element access time. Internal layout can be optimized by method <a class="el" href="a00047.html#af2101247808fd0e81b992724e317a7f3" title="An alias for shrink_to_fit().">compact()</a> that merges several smaller arrays into one solid.</dd></dl>
<dl class="user"><dt><b>Changes since TBB 2.1</b></dt><dd><ul>
<li>Fixed guarantees of <a class="el" href="a00047.html#a803268c16e3688ff4681251947d257c7" title="Return size of vector. It may include elements under construction.">concurrent_vector::size()</a> and <a class="el" href="a00047.html#af52b603dd76a99dffe5760f0db4747f1" title="Append minimal sequence of elements such that size()&gt;=n.">grow_to_at_least()</a> methods to assure elements are allocated.</li>
<li>Methods <a class="el" href="a00047.html#aad2c07653375e4a5f89c33b375eda610" title="end iterator">end()</a>/rbegin()/back() are partly thread-safe since they use <a class="el" href="a00047.html#a803268c16e3688ff4681251947d257c7" title="Return size of vector. It may include elements under construction.">size()</a> to get the end of vector</li>
<li>Added <a class="el" href="a00047.html#a65e53a98a1e1fdb515fdc2b84e2314e8" title="Resize the vector. Not thread-safe.">resize()</a> methods (not thread-safe)</li>
<li>Added cbegin/cend/crbegin/crend methods</li>
<li>Changed return type of methods grow* and push_back to iterator</li>
</ul>
</dd></dl>
<dl class="user"><dt><b>Changes since TBB 2.0</b></dt><dd><ul>
<li>Implemented exception-safety guarantees</li>
<li>Added template argument for allocator</li>
<li>Added allocator argument in constructors</li>
<li>Faster index calculation</li>
<li>First growth call specifies a number of segments to be merged in the first allocation.</li>
<li>Fixed memory blow up for swarm of vector's instances of small size</li>
<li>Added <a class="el" href="a00047.html#a9dae5d9368fd852426552b21d67beb86" title="Grow by &quot;delta&quot; elements using copying constructor.">grow_by(size_type n, const_reference t)</a> growth using copying constructor to init new items.</li>
<li>Added STL-like constructors.</li>
<li>Added operators ==, &lt; and derivatives</li>
<li>Added <a class="el" href="a00047.html#a629a29eb21e528414b9d5c9becfe05cd" title="Get reference to element at given index. Throws exceptions on errors.">at()</a> method, approved for using after an exception was thrown inside the vector</li>
<li>Added <a class="el" href="a00047.html#a88b62a9614d3f2b59c9c7c1a2143fb1e" title="return allocator object">get_allocator()</a> method.</li>
<li>Added <a class="el" href="a00047.html#a87355dce93d0882aa73333a35c9b367c" title="assign n items by copying t item">assign()</a> methods</li>
<li>Added <a class="el" href="a00047.html#af2101247808fd0e81b992724e317a7f3" title="An alias for shrink_to_fit().">compact()</a> method to defragment first segments</li>
<li>Added <a class="el" href="a00047.html#a8603bd57324fb6b60ba006884c95279d" title="swap two instances">swap()</a> method</li>
<li><a class="el" href="a00047.html#a8201f65735edcc28aeec95b6e73d75b6" title="Get range for iterating with parallel algorithms.">range()</a> defaults on grainsize = 1 supporting auto grainsize algorithms. </li>
</ul>
</dd></dl>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a526ba408fb3064ef846940d633b8f365"></a><!-- doxytag: member="tbb::concurrent_vector::clear" ref="a526ba408fb3064ef846940d633b8f365" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00047.html">tbb::concurrent_vector</a>&lt; T, A &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear container while keeping memory allocated. </p>
<p>To free up the memory, use in conjunction with method <a class="el" href="a00047.html#af2101247808fd0e81b992724e317a7f3" title="An alias for shrink_to_fit().">compact()</a>. Not thread safe </p>

</div>
</div>
<a class="anchor" id="aa11fc991cda82cf93789fce31b37a16c"></a><!-- doxytag: member="tbb::concurrent_vector::grow_by" ref="aa11fc991cda82cf93789fce31b37a16c" args="(size_type delta, const_reference t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a00047.html">tbb::concurrent_vector</a>&lt; T, A &gt;::grow_by </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_reference&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns iterator pointing to the first new element. </p>

</div>
</div>
<a class="anchor" id="a9dae5d9368fd852426552b21d67beb86"></a><!-- doxytag: member="tbb::concurrent_vector::grow_by" ref="a9dae5d9368fd852426552b21d67beb86" args="(size_type delta, const_reference t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="a00047.html">tbb::concurrent_vector</a>&lt; T, A &gt;::grow_by </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_reference&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Grow by "delta" elements using copying constructor. </p>
<p>Returns old size. </p>

</div>
</div>
<a class="anchor" id="ab89c2db5358048debdc282ff995caffb"></a><!-- doxytag: member="tbb::concurrent_vector::grow_by" ref="ab89c2db5358048debdc282ff995caffb" args="(size_type delta)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a00047.html">tbb::concurrent_vector</a>&lt; T, A &gt;::grow_by </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>delta</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns iterator pointing to the first new element. </p>

</div>
</div>
<a class="anchor" id="a9c8452b88bc79c3c88d47c455064c012"></a><!-- doxytag: member="tbb::concurrent_vector::grow_by" ref="a9c8452b88bc79c3c88d47c455064c012" args="(size_type delta)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="a00047.html">tbb::concurrent_vector</a>&lt; T, A &gt;::grow_by </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>delta</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Grow by "delta" elements. </p>
<p>Returns old size. </p>

</div>
</div>
<a class="anchor" id="ae9ef9895e88f9bf036b379035c18f035"></a><!-- doxytag: member="tbb::concurrent_vector::grow_to_at_least" ref="ae9ef9895e88f9bf036b379035c18f035" args="(size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a00047.html">tbb::concurrent_vector</a>&lt; T, A &gt;::grow_to_at_least </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The new elements are default constructed. Blocks until all elements in range [0..n) are allocated. May return while other elements are being constructed by other threads. Returns iterator that points to beginning of appended sequence. If no elements were appended, returns iterator pointing to nth element. </p>

</div>
</div>
<a class="anchor" id="af52b603dd76a99dffe5760f0db4747f1"></a><!-- doxytag: member="tbb::concurrent_vector::grow_to_at_least" ref="af52b603dd76a99dffe5760f0db4747f1" args="(size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00047.html">tbb::concurrent_vector</a>&lt; T, A &gt;::grow_to_at_least </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append minimal sequence of elements such that <a class="el" href="a00047.html#a803268c16e3688ff4681251947d257c7" title="Return size of vector. It may include elements under construction.">size()</a>&gt;=n. </p>
<p>The new elements are default constructed. Blocks until all elements in range [0..n) are allocated. May return while other elements are being constructed by other threads. </p>

</div>
</div>
<a class="anchor" id="a3097cb46511504acfc9de7da5235f4a6"></a><!-- doxytag: member="tbb::concurrent_vector::operator[]" ref="a3097cb46511504acfc9de7da5235f4a6" args="(size_type index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="a00047.html">tbb::concurrent_vector</a>&lt; T, A &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get reference to element at given index. </p>
<p>This method is thread-safe for concurrent reads, and also while growing the vector, as long as the calling thread has checked that index&lt;<a class="el" href="a00047.html#a803268c16e3688ff4681251947d257c7" title="Return size of vector. It may include elements under construction.">size()</a>. </p>

</div>
</div>
<a class="anchor" id="a4a5c85a9e6ff82e15c18da47a95b518f"></a><!-- doxytag: member="tbb::concurrent_vector::push_back" ref="a4a5c85a9e6ff82e15c18da47a95b518f" args="(const_reference item) iterator push_back(const _reference item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="a00047.html">tbb::concurrent_vector</a>&lt; T, A &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const_reference&nbsp;</td>
          <td class="paramname"> <em>item</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push item. </p>
<p>Returns iterator pointing to the new element. </p>

</div>
</div>
<a class="anchor" id="a0b3284684328c58c0228c9a697ef3594"></a><!-- doxytag: member="tbb::concurrent_vector::reserve" ref="a0b3284684328c58c0228c9a697ef3594" args="(size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00047.html">tbb::concurrent_vector</a>&lt; T, A &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate enough space to grow to size n without having to allocate more memory later. </p>
<p>Like most of the methods provided for STL compatibility, this method is *not* thread safe. The capacity afterwards may be bigger than the requested reservation. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00190_source.html">concurrent_vector.h</a></li>
</ul>
</div>
<hr>
<p></p>
Copyright &copy; 2005-2013 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
