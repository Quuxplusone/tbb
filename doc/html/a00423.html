<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>tbb Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li id="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="namespaces.html"><span>Namespace List</span></a></li>
    <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
  </ul></div>
<h1>tbb Namespace Reference</h1>The namespace tbb contains all components of the library.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00260.html">aligned_space</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block of space aligned sufficiently to construct an array T with N elements.  <a href="a00260.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00261.html">atomic</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Primary template for atomic.  <a href="a00261.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html">atomic&lt; void * &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for <a class="el" href="a00262.html">atomic&lt;void*&gt;</a>, for sake of not allowing arithmetic or operator-&gt;.  <a href="a00262.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00266.html">blocked_range</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A range over which to iterate.  <a href="a00266.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html">blocked_range2d</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A 2-dimensional range that models the Range concept.  <a href="a00267.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00268.html">blocked_range3d</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A 3-dimensional range that models the Range concept.  <a href="a00268.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00271.html">cache_aligned_allocator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5.  <a href="a00271.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00272.html">cache_aligned_allocator&lt; void &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00272.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00274.html">combinable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread-local storage with optional reduction.  <a href="a00274.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00355.html">tbb_hash_compare</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">hash_compare that is default argument for concurrent_hash_map  <a href="a00355.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html">concurrent_bounded_queue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A high-performance thread-safe blocking concurrent bounded queue.  <a href="a00275.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00283.html">concurrent_vector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concurrent vector container.  <a href="a00283.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00308.html">mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper around the platform's native reader-writer lock.  <a href="a00308.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00310.html">null_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A mutex which does nothing.  <a href="a00310.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00312.html">null_rw_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A rw mutex which does nothing.  <a href="a00312.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00314.html">parallel_do_feeder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class the user supplied algorithm body uses to add new tasks.  <a href="a00314.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00347.html">task_group_context</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00318.html">pre_scan_tag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to indicate that the initial scan is being performed.  <a href="a00318.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00291.html">final_scan_tag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to indicate that the final scan is being performed.  <a href="a00291.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.html">parallel_while</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over a stream, with optional addition of more work.  <a href="a00315.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00336.html">simple_partitioner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A simple partitioner.  <a href="a00336.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00264.html">auto_partitioner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An auto partitioner.  <a href="a00264.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00256.html">affinity_partitioner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An affinity partitioner.  <a href="a00256.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00289.html">filter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A stage in a pipeline.  <a href="a00289.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00356.html">thread_bound_filter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A stage in a pipeline served by a user thread.  <a href="a00356.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00317.html">pipeline</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A processing pipeline that applies filters to items.  <a href="a00317.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00321.html">queuing_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queuing mutex with local-only spinning.  <a href="a00321.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00323.html">queuing_rw_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queuing reader-writer mutex with local-only spinning.  <a href="a00323.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00329.html">recursive_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mutex that allows recursive mutex acquisition.  <a href="a00329.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00332.html">scalable_allocator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5.  <a href="a00332.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00333.html">scalable_allocator&lt; void &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00333.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00338.html">spin_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A lock that occupies a single byte.  <a href="a00338.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00340.html">spin_rw_mutex_v3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast, unfair, spinning reader-writer lock with backoff and writer-preference.  <a href="a00340.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html">task</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for user-defined tasks.  <a href="a00344.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00287.html">empty_task</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">task that does nothing. Useful for synchronization.  <a href="a00287.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00349.html">task_list</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A list of children.  <a href="a00349.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>task_handle</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>task_group</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>structured_task_group</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00350.html">task_scheduler_init</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class delimiting the scope of task scheduler activity.  <a href="a00350.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00351.html">tbb_allocator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5.  <a href="a00351.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00352.html">tbb_allocator&lt; void &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00352.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00361.html">zero_allocator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5.  <a href="a00361.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00362.html">zero_allocator&lt; void, Allocator &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00362.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html">bad_last_alloc</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception for concurrent containers.  <a href="a00265.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00297.html">improper_lock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception for PPL locks.  <a href="a00297.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html">user_abort</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception for user-initiated abort.  <a href="a00359.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00305.html">missing_wait</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception for missing wait on structured_task_group.  <a href="a00305.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html">invalid_multiple_scheduling</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception for repeated scheduling of the same task_handle.  <a href="a00298.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00353.html">tbb_exception</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface to be implemented by all exceptions TBB recognizes and propagates across the threads.  <a href="a00353.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00273.html">captured_exception</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is used by TBB to propagate information about unhandled exceptions into the root thread.  <a href="a00273.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00306.html">movable_exception</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Template that can be used to implement exception that transfers arbitrary ExceptionData to the root thread.  <a href="a00306.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00342.html">split</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dummy type that distinguishes splitting constructor from copy constructor.  <a href="a00342.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00357.html">tick_count</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Absolute timestamp.  <a href="a00357.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>parallel_do</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="parallel_do_body_req.html">parallel_do Body</a>. <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g2bff63883d023abb09d236c69a177cb0"></a><!-- doxytag: member="tbb::parallel_do" ref="g2bff63883d023abb09d236c69a177cb0" args="(Iterator first, Iterator last, const Body &amp;body)" -->
template&lt;typename Iterator, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g2bff63883d023abb09d236c69a177cb0">parallel_do</a> (Iterator first, Iterator last, const Body &amp;body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over a range, with optional addition of more work. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gf02bc6290b7866d4ad1de75bb07f762b"></a><!-- doxytag: member="tbb::parallel_do" ref="gf02bc6290b7866d4ad1de75bb07f762b" args="(Iterator first, Iterator last, const Body &amp;body, task_group_context &amp;context)" -->
template&lt;typename Iterator, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#gf02bc6290b7866d4ad1de75bb07f762b">parallel_do</a> (Iterator first, Iterator last, const Body &amp;body, <a class="el" href="a00347.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over a range, with optional addition of more work and user-supplied context. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_for</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="range_req.html">Range</a> and <a class="el" href="parallel_for_body_req.html">parallel_for Body</a>. <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g809af9d6d765ac0c7b4149d1b364479f"></a><!-- doxytag: member="tbb::parallel_for" ref="g809af9d6d765ac0c7b4149d1b364479f" args="(const Range &amp;range, const Body &amp;body)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g809af9d6d765ac0c7b4149d1b364479f">parallel_for</a> (const Range &amp;range, const Body &amp;body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with default partitioner. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gf450e3d3a604d1618110072dfb1e0cbe"></a><!-- doxytag: member="tbb::parallel_for" ref="gf450e3d3a604d1618110072dfb1e0cbe" args="(const Range &amp;range, const Body &amp;body, const simple_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#gf450e3d3a604d1618110072dfb1e0cbe">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00336.html">simple_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with simple partitioner. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g27e05270168bd7bf241eca1e98ed57ef"></a><!-- doxytag: member="tbb::parallel_for" ref="g27e05270168bd7bf241eca1e98ed57ef" args="(const Range &amp;range, const Body &amp;body, const auto_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g27e05270168bd7bf241eca1e98ed57ef">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00264.html">auto_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00264.html">auto_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g157a7f91932c506c50181e2133353639"></a><!-- doxytag: member="tbb::parallel_for" ref="g157a7f91932c506c50181e2133353639" args="(const Range &amp;range, const Body &amp;body, affinity_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g157a7f91932c506c50181e2133353639">parallel_for</a> (const Range &amp;range, const Body &amp;body, <a class="el" href="a00256.html">affinity_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00256.html">affinity_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g4ba06c6b19f5530ad604b65f4137c97f"></a><!-- doxytag: member="tbb::parallel_for" ref="g4ba06c6b19f5530ad604b65f4137c97f" args="(const Range &amp;range, const Body &amp;body, task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g4ba06c6b19f5530ad604b65f4137c97f">parallel_for</a> (const Range &amp;range, const Body &amp;body, <a class="el" href="a00347.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with default partitioner and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g975260c595b505d13b442897f044c124"></a><!-- doxytag: member="tbb::parallel_for" ref="g975260c595b505d13b442897f044c124" args="(const Range &amp;range, const Body &amp;body, const simple_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g975260c595b505d13b442897f044c124">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00336.html">simple_partitioner</a> &amp;partitioner, <a class="el" href="a00347.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with simple partitioner and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gecb7deb88c8ca869cd3245800435e68d"></a><!-- doxytag: member="tbb::parallel_for" ref="gecb7deb88c8ca869cd3245800435e68d" args="(const Range &amp;range, const Body &amp;body, const auto_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#gecb7deb88c8ca869cd3245800435e68d">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00264.html">auto_partitioner</a> &amp;partitioner, <a class="el" href="a00347.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00264.html">auto_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gaccc2568e8f502751a6de09da6b144ba"></a><!-- doxytag: member="tbb::parallel_for" ref="gaccc2568e8f502751a6de09da6b144ba" args="(const Range &amp;range, const Body &amp;body, affinity_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#gaccc2568e8f502751a6de09da6b144ba">parallel_for</a> (const Range &amp;range, const Body &amp;body, <a class="el" href="a00256.html">affinity_partitioner</a> &amp;partitioner, <a class="el" href="a00347.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00256.html">affinity_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_for_each</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g9465bfb7d751f5b167f446d6933934b9"></a><!-- doxytag: member="tbb::parallel_for_each" ref="g9465bfb7d751f5b167f446d6933934b9" args="(InputIterator first, InputIterator last, const Function &amp;f, task_group_context &amp;context)" -->
template&lt;typename InputIterator, typename Function&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g9465bfb7d751f5b167f446d6933934b9">parallel_for_each</a> (InputIterator first, InputIterator last, const Function &amp;f, <a class="el" href="a00347.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls function f for all items from [first, last) interval using user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g92a4c382c663a1b3120d6f434ba5e36e"></a><!-- doxytag: member="tbb::parallel_for_each" ref="g92a4c382c663a1b3120d6f434ba5e36e" args="(InputIterator first, InputIterator last, const Function &amp;f)" -->
template&lt;typename InputIterator, typename Function&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g92a4c382c663a1b3120d6f434ba5e36e">parallel_for_each</a> (InputIterator first, InputIterator last, const Function &amp;f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses default context. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_invoke</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g0ca48b0a7be3615b3b9f538112616076"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g0ca48b0a7be3615b3b9f538112616076" args="(const F0 &amp;f0, const F1 &amp;f1, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g0ca48b0a7be3615b3b9f538112616076">parallel_invoke</a> (const F0 &amp;f0, const F1 &amp;f1, <a class="el" href="a00347.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes a list of tasks in parallel and waits for all tasks to complete. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g1b257aa33f7d6c79dc4c242b7b481e70"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g1b257aa33f7d6c79dc4c242b7b481e70" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, <a class="el" href="a00347.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g14bb2af2f85c990286b64da6087ba19d"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g14bb2af2f85c990286b64da6087ba19d" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2, typename F3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, <a class="el" href="a00347.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g03e53f2d34abf02771b6cd92de56258b"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g03e53f2d34abf02771b6cd92de56258b" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, <a class="el" href="a00347.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gb5b0744238c029b76eebbd48dbd71867"></a><!-- doxytag: member="tbb::parallel_invoke" ref="gb5b0744238c029b76eebbd48dbd71867" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, <a class="el" href="a00347.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga2b2e5546e59df7497d3fd8bb42a4f9b"></a><!-- doxytag: member="tbb::parallel_invoke" ref="ga2b2e5546e59df7497d3fd8bb42a4f9b" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, <a class="el" href="a00347.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g3a207900c8b529b399322065e590402c"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g3a207900c8b529b399322065e590402c" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, <a class="el" href="a00347.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gdbc0ae6c5e0558f383c7917dbbac4c44"></a><!-- doxytag: member="tbb::parallel_invoke" ref="gdbc0ae6c5e0558f383c7917dbbac4c44" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8, <a class="el" href="a00347.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g12f9ad0999e830eac907ab36abd26a16"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g12f9ad0999e830eac907ab36abd26a16" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8, const F9 &amp;f9, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8, const F9 &amp;f9, <a class="el" href="a00347.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g15041e61e27d15ca4d7d00daf8e41d69"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g15041e61e27d15ca4d7d00daf8e41d69" args="(const F0 &amp;f0, const F1 &amp;f1)" -->
template&lt;typename F0, typename F1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gb0906227fac7d485df19eeed7a418259"></a><!-- doxytag: member="tbb::parallel_invoke" ref="gb0906227fac7d485df19eeed7a418259" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2)" -->
template&lt;typename F0, typename F1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g59d1e4d81d98310b37b8e7056af4a6d4"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g59d1e4d81d98310b37b8e7056af4a6d4" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3)" -->
template&lt;typename F0, typename F1, typename F2, typename F3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g927a13f932a2c3a460268e1ac474c15b"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g927a13f932a2c3a460268e1ac474c15b" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga8ec54b7f5847024114ff84adbe538c0"></a><!-- doxytag: member="tbb::parallel_invoke" ref="ga8ec54b7f5847024114ff84adbe538c0" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g34ff3436fbb03e07548b2464c927818d"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g34ff3436fbb03e07548b2464c927818d" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ge54b6f2a7cf110bd70515e33da26a5be"></a><!-- doxytag: member="tbb::parallel_invoke" ref="ge54b6f2a7cf110bd70515e33da26a5be" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g21a3d80287bb4662512e7dee88ec91bb"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g21a3d80287bb4662512e7dee88ec91bb" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g24440d67c8e12ca59f53a5913439c902"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g24440d67c8e12ca59f53a5913439c902" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8, const F9 &amp;f9)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8, const F9 &amp;f9)</td></tr>

<tr><td colspan="2"><br><h2>parallel_reduce</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="range_req.html">Range</a> and <a class="el" href="parallel_reduce_body_req.html">parallel_reduce Body</a>. <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g952536d8b82089d2780e552cc42081c6"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g952536d8b82089d2780e552cc42081c6" args="(const Range &amp;range, Body &amp;body)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g952536d8b82089d2780e552cc42081c6">parallel_reduce</a> (const Range &amp;range, Body &amp;body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and default partitioner. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gaf173f545cc4c5c635d48ca455cf8aa7"></a><!-- doxytag: member="tbb::parallel_reduce" ref="gaf173f545cc4c5c635d48ca455cf8aa7" args="(const Range &amp;range, Body &amp;body, const simple_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#gaf173f545cc4c5c635d48ca455cf8aa7">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00336.html">simple_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00336.html">simple_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g1605f10c9af1e0dc4d51d17d6e6b1446"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g1605f10c9af1e0dc4d51d17d6e6b1446" args="(const Range &amp;range, Body &amp;body, const auto_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g1605f10c9af1e0dc4d51d17d6e6b1446">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00264.html">auto_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00264.html">auto_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g22a6bd324785146fa9c8fa343c975194"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g22a6bd324785146fa9c8fa343c975194" args="(const Range &amp;range, Body &amp;body, affinity_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g22a6bd324785146fa9c8fa343c975194">parallel_reduce</a> (const Range &amp;range, Body &amp;body, <a class="el" href="a00256.html">affinity_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00256.html">affinity_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g35f71209bf3addde62379b4a7976b273"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g35f71209bf3addde62379b4a7976b273" args="(const Range &amp;range, Body &amp;body, const simple_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g35f71209bf3addde62379b4a7976b273">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00336.html">simple_partitioner</a> &amp;partitioner, <a class="el" href="a00347.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, simple partitioner and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g93b01fd8e3a77c1b066c4ad1cae7ae2d"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g93b01fd8e3a77c1b066c4ad1cae7ae2d" args="(const Range &amp;range, Body &amp;body, const auto_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g93b01fd8e3a77c1b066c4ad1cae7ae2d">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00264.html">auto_partitioner</a> &amp;partitioner, <a class="el" href="a00347.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00264.html">auto_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g42193506a329a605af9df6bc4dddc546"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g42193506a329a605af9df6bc4dddc546" args="(const Range &amp;range, Body &amp;body, affinity_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g42193506a329a605af9df6bc4dddc546">parallel_reduce</a> (const Range &amp;range, Body &amp;body, <a class="el" href="a00256.html">affinity_partitioner</a> &amp;partitioner, <a class="el" href="a00347.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00256.html">affinity_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga9322987a244031f98b0cd3b8a6e11e5"></a><!-- doxytag: member="tbb::parallel_reduce" ref="ga9322987a244031f98b0cd3b8a6e11e5" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#ga9322987a244031f98b0cd3b8a6e11e5">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and default partitioner. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gbd49b7d7f63dc92429c33c1d069ccdcd"></a><!-- doxytag: member="tbb::parallel_reduce" ref="gbd49b7d7f63dc92429c33c1d069ccdcd" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const simple_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#gbd49b7d7f63dc92429c33c1d069ccdcd">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00336.html">simple_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00336.html">simple_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g0cecf9a429cd7ac8a5aa78b16b4ca635"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g0cecf9a429cd7ac8a5aa78b16b4ca635" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const auto_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g0cecf9a429cd7ac8a5aa78b16b4ca635">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00264.html">auto_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00264.html">auto_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g4f4a29c725a3710773be023af003b9fc"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g4f4a29c725a3710773be023af003b9fc" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, affinity_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g4f4a29c725a3710773be023af003b9fc">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, <a class="el" href="a00256.html">affinity_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00256.html">affinity_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g7a6265e951dfeb9b88dbdf76777a45a0"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g7a6265e951dfeb9b88dbdf76777a45a0" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const simple_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g7a6265e951dfeb9b88dbdf76777a45a0">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00336.html">simple_partitioner</a> &amp;partitioner, <a class="el" href="a00347.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, simple partitioner and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga3733a5e32f4eada6ba70c0b82800f4d"></a><!-- doxytag: member="tbb::parallel_reduce" ref="ga3733a5e32f4eada6ba70c0b82800f4d" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const auto_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#ga3733a5e32f4eada6ba70c0b82800f4d">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00264.html">auto_partitioner</a> &amp;partitioner, <a class="el" href="a00347.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00264.html">auto_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g21b6569b0503cca66b416f4ec7d43115"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g21b6569b0503cca66b416f4ec7d43115" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, affinity_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g21b6569b0503cca66b416f4ec7d43115">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, <a class="el" href="a00256.html">affinity_partitioner</a> &amp;partitioner, <a class="el" href="a00347.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00256.html">affinity_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g35ec7bc7b290da23aade5720dd145029"></a><!-- doxytag: member="tbb::parallel_deterministic_reduce" ref="g35ec7bc7b290da23aade5720dd145029" args="(const Range &amp;range, Body &amp;body)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g35ec7bc7b290da23aade5720dd145029">parallel_deterministic_reduce</a> (const Range &amp;range, Body &amp;body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with deterministic reduction and default partitioner. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g2ab8956163947123876467dcbcbb5efe"></a><!-- doxytag: member="tbb::parallel_deterministic_reduce" ref="g2ab8956163947123876467dcbcbb5efe" args="(const Range &amp;range, Body &amp;body, task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g2ab8956163947123876467dcbcbb5efe">parallel_deterministic_reduce</a> (const Range &amp;range, Body &amp;body, <a class="el" href="a00347.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with deterministic reduction, simple partitioner and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gf70b6fe2200079155f8c7df482e2701d"></a><!-- doxytag: member="tbb::parallel_deterministic_reduce" ref="gf70b6fe2200079155f8c7df482e2701d" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#gf70b6fe2200079155f8c7df482e2701d">parallel_deterministic_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with deterministic reduction and default partitioner. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga2e76735ef24d8630fc5288af0c2590a"></a><!-- doxytag: member="tbb::parallel_deterministic_reduce" ref="ga2e76735ef24d8630fc5288af0c2590a" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, task_group_context &amp;context)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#ga2e76735ef24d8630fc5288af0c2590a">parallel_deterministic_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, <a class="el" href="a00347.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with deterministic reduction, simple partitioner and user-supplied context. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_scan</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="range_req.html">Range</a> and <a class="el" href="parallel_scan_body_req.html">parallel_scan Body</a>. <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gd337596ece330206040f6488a19b6779"></a><!-- doxytag: member="tbb::parallel_scan" ref="gd337596ece330206040f6488a19b6779" args="(const Range &amp;range, Body &amp;body)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#gd337596ece330206040f6488a19b6779">parallel_scan</a> (const Range &amp;range, Body &amp;body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel prefix with default partitioner. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g2a2e1a2939691abfd1e1ff3874104a44"></a><!-- doxytag: member="tbb::parallel_scan" ref="g2a2e1a2939691abfd1e1ff3874104a44" args="(const Range &amp;range, Body &amp;body, const simple_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g2a2e1a2939691abfd1e1ff3874104a44">parallel_scan</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00336.html">simple_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel prefix with <a class="el" href="a00336.html">simple_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gb29140dc991625ed05c9f8fe1526ea96"></a><!-- doxytag: member="tbb::parallel_scan" ref="gb29140dc991625ed05c9f8fe1526ea96" args="(const Range &amp;range, Body &amp;body, const auto_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#gb29140dc991625ed05c9f8fe1526ea96">parallel_scan</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00264.html">auto_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel prefix with <a class="el" href="a00264.html">auto_partitioner</a>. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_sort</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="parallel_sort_iter_req.html">iterators for parallel_sort</a>. <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename RandomAccessIterator, typename Compare&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g95e48e87618aa34aa88619ae06c3d81d">parallel_sort</a> (RandomAccessIterator begin, RandomAccessIterator end, const Compare &amp;comp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the data in [begin,end) using the given comparator.  <a href="a00436.html#g95e48e87618aa34aa88619ae06c3d81d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g04aec2bd09cc56812b8ab2a2f24568ad"></a><!-- doxytag: member="tbb::parallel_sort" ref="g04aec2bd09cc56812b8ab2a2f24568ad" args="(RandomAccessIterator begin, RandomAccessIterator end)" -->
template&lt;typename RandomAccessIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g04aec2bd09cc56812b8ab2a2f24568ad">parallel_sort</a> (RandomAccessIterator begin, RandomAccessIterator end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the data in [begin,end) with a default comparator <code>std::less&lt;RandomAccessIterator&gt;</code>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g7204c5b60eb4ac1eb325c60e0bfe42a9"></a><!-- doxytag: member="tbb::parallel_sort" ref="g7204c5b60eb4ac1eb325c60e0bfe42a9" args="(T *begin, T *end)" -->
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00436.html#g7204c5b60eb4ac1eb325c60e0bfe42a9">parallel_sort</a> (T *begin, T *end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the data in the range <code></code>[begin,end) with a default comparator <code>std::less&lt;T&gt;</code>. <br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="889d8f126388fdc24c597d195a4d7028"></a><!-- doxytag: member="tbb::critical_section" ref="889d8f126388fdc24c597d195a4d7028" args="" -->
typedef internal::critical_section_v4&nbsp;</td><td class="memItemRight" valign="bottom"><b>critical_section</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6cc3d02744cab8ac389919806d47e417"></a><!-- doxytag: member="tbb::spin_rw_mutex" ref="6cc3d02744cab8ac389919806d47e417" args="" -->
typedef <a class="el" href="a00340.html">spin_rw_mutex_v3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>spin_rw_mutex</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1a268320974a3357e9609a2f98be5090"></a><!-- doxytag: member="tbb::stack_size_type" ref="1a268320974a3357e9609a2f98be5090" args="" -->
typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>stack_size_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f58de4ab3200dd2bd621f052c6f677e4"></a><!-- doxytag: member="tbb::task_scheduler_observer" ref="f58de4ab3200dd2bd621f052c6f677e4" args="" -->
typedef tbb::internal::task_scheduler_observer_v3&nbsp;</td><td class="memItemRight" valign="bottom"><b>task_scheduler_observer</b></td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00423.html#db86d08473679d6fe0eabcdc766ffe3a">memory_semantics</a> { <a class="el" href="a00423.html#db86d08473679d6fe0eabcdc766ffe3a6a315190cf4509ec388ecb423432f36a">full_fence</a>, 
<a class="el" href="a00423.html#db86d08473679d6fe0eabcdc766ffe3aa92646b4dc7618530d3a9f51dd10a418">acquire</a>, 
<a class="el" href="a00423.html#db86d08473679d6fe0eabcdc766ffe3a412563418e657114a102db610f726632">release</a>, 
<a class="el" href="a00423.html#db86d08473679d6fe0eabcdc766ffe3a73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies memory semantics.  <a href="a00423.html#db86d08473679d6fe0eabcdc766ffe3a">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00423.html#c5bcb6154c8307fa9f97806afddf2288">ets_key_usage_type</a> { <b>ets_key_per_instance</b>, 
<b>ets_no_key</b>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">enum for selecting between single key and key-per-instance versions <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>priority_t</b> { <b>priority_normal</b> =  internal::priority_stride_v4 * 2, 
<b>priority_low</b> =  priority_normal - internal::priority_stride_v4, 
<b>priority_high</b> =  priority_normal + internal::priority_stride_v4
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>task_group_status</b> { <b>not_complete</b>, 
<b>complete</b>, 
<b>canceled</b>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5fefe7ed201b920d3fd6c390849c1ccf"></a><!-- doxytag: member="tbb::__TBB_DECL_ATOMIC" ref="5fefe7ed201b920d3fd6c390849c1ccf" args="(__TBB_LONG_LONG) __TBB_DECL_ATOMIC(unsigned __TBB_LONG_LONG) __TBB_DECL_ATOMIC(long) __TBB_DECL_ATOMIC(unsigned long) __TBB_DECL_ATOMIC_ALT(unsigned" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>__TBB_DECL_ATOMIC</b> (__TBB_LONG_LONG) __TBB_DECL_ATOMIC(unsigned __TBB_LONG_LONG) __TBB_DECL_ATOMIC(long) __TBB_DECL_ATOMIC(unsigned long) __TBB_DECL_ATOMIC_ALT(unsigned</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="59425abdcb421136e9f5954cfb975e5f"></a><!-- doxytag: member="tbb::__TBB_DECL_ATOMIC_ALT" ref="59425abdcb421136e9f5954cfb975e5f" args="(int, ptrdiff_t) __TBB_DECL_ATOMIC(unsigned) __TBB_DECL_ATOMIC(int) __TBB_DECL_ATOMIC(unsigned short) __TBB_DECL_ATOMIC(short) __TBB_DECL_ATOMIC(char) __TBB_DECL_ATOMIC(signed char) __TBB_DECL_ATOMIC(unsigned char) __TBB_DECL_ATOMIC(wchar_t) template&lt; typename T &gt; struct atomic&lt; T * &gt;" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00423.html#59425abdcb421136e9f5954cfb975e5f">__TBB_DECL_ATOMIC_ALT</a> (int, ptrdiff_t) __TBB_DECL_ATOMIC(unsigned) __TBB_DECL_ATOMIC(int) __TBB_DECL_ATOMIC(unsigned short) __TBB_DECL_ATOMIC(short) __TBB_DECL_ATOMIC(char) __TBB_DECL_ATOMIC(signed char) __TBB_DECL_ATOMIC(unsigned char) __TBB_DECL_ATOMIC(wchar_t) template&lt; typename T &gt; struct <a class="el" href="a00261.html">atomic</a>&lt; T * &gt;</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for atomic&lt;T*&gt; with arithmetic and operator-&gt;. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a8e5f924093138307aa7c4d6285cdea5"></a><!-- doxytag: member="tbb::load" ref="a8e5f924093138307aa7c4d6285cdea5" args="(const atomic&lt; T &gt; &amp;a)" -->
template&lt;memory_semantics M, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>load</b> (const <a class="el" href="a00261.html">atomic</a>&lt; T &gt; &amp;a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="7aeede60c40d5a4edad3553252b29694"></a><!-- doxytag: member="tbb::store" ref="7aeede60c40d5a4edad3553252b29694" args="(atomic&lt; T &gt; &amp;a, T value)" -->
template&lt;memory_semantics M, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>store</b> (<a class="el" href="a00261.html">atomic</a>&lt; T &gt; &amp;a, T value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="1b2276ee833170891664f250651ff3ee"></a><!-- doxytag: member="tbb::operator==" ref="1b2276ee833170891664f250651ff3ee" args="(const cache_aligned_allocator&lt; T &gt; &amp;, const cache_aligned_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00271.html">cache_aligned_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00271.html">cache_aligned_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="c9a723aec9ae9162676dd850b2d31d53"></a><!-- doxytag: member="tbb::operator!=" ref="c9a723aec9ae9162676dd850b2d31d53" args="(const cache_aligned_allocator&lt; T &gt; &amp;, const cache_aligned_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00271.html">cache_aligned_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00271.html">cache_aligned_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="8b5f60bc21f5db841e4b4cfc20c07a45"></a><!-- doxytag: member="tbb::operator==" ref="8b5f60bc21f5db841e4b4cfc20c07a45" args="(const concurrent_hash_map&lt; Key, T, HashCompare, A1 &gt; &amp;a, const concurrent_hash_map&lt; Key, T, HashCompare, A2 &gt; &amp;b)" -->
template&lt;typename Key, typename T, typename HashCompare, typename A1, typename A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00276.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A1 &gt; &amp;a, const <a class="el" href="a00276.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="15c8ae40cf454f1487b1a202cbad7369"></a><!-- doxytag: member="tbb::operator!=" ref="15c8ae40cf454f1487b1a202cbad7369" args="(const concurrent_hash_map&lt; Key, T, HashCompare, A1 &gt; &amp;a, const concurrent_hash_map&lt; Key, T, HashCompare, A2 &gt; &amp;b)" -->
template&lt;typename Key, typename T, typename HashCompare, typename A1, typename A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00276.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A1 &gt; &amp;a, const <a class="el" href="a00276.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="992318870d30e96f75404d9c8cc65c8e"></a><!-- doxytag: member="tbb::swap" ref="992318870d30e96f75404d9c8cc65c8e" args="(concurrent_hash_map&lt; Key, T, HashCompare, A &gt; &amp;a, concurrent_hash_map&lt; Key, T, HashCompare, A &gt; &amp;b)" -->
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="a00276.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt; &amp;a, <a class="el" href="a00276.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="f6460b8dd7db1ae82fce7e0dd32199f1"></a><!-- doxytag: member="tbb::operator==" ref="f6460b8dd7db1ae82fce7e0dd32199f1" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00283.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00283.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="30f917166e03c6ce6a7de793f98c9d30"></a><!-- doxytag: member="tbb::operator!=" ref="30f917166e03c6ce6a7de793f98c9d30" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00283.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00283.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="1b009d587157273622139bc6b03f1771"></a><!-- doxytag: member="tbb::operator&lt;" ref="1b009d587157273622139bc6b03f1771" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="a00283.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00283.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a277363fadae7c6e03333f4da0f17ad0"></a><!-- doxytag: member="tbb::operator&gt;" ref="a277363fadae7c6e03333f4da0f17ad0" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="a00283.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00283.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="273dfe160cca44b7b8975b8d78d7268e"></a><!-- doxytag: member="tbb::operator&lt;=" ref="273dfe160cca44b7b8975b8d78d7268e" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="a00283.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00283.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="0b11711c75d79aba35fe67435271fbb6"></a><!-- doxytag: member="tbb::operator&gt;=" ref="0b11711c75d79aba35fe67435271fbb6" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="a00283.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00283.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="fe4c5745b2e460de448602a95f7ad4c0"></a><!-- doxytag: member="tbb::swap" ref="fe4c5745b2e460de448602a95f7ad4c0" args="(concurrent_vector&lt; T, A &gt; &amp;a, concurrent_vector&lt; T, A &gt; &amp;b)" -->
template&lt;typename T, class A&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="a00283.html">concurrent_vector</a>&lt; T, A &gt; &amp;a, <a class="el" href="a00283.html">concurrent_vector</a>&lt; T, A &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="86ff5d4e516a1b8d4857719a8b30c3b7"></a><!-- doxytag: member="tbb::operator==" ref="86ff5d4e516a1b8d4857719a8b30c3b7" args="(const scalable_allocator&lt; T &gt; &amp;, const scalable_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00332.html">scalable_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00332.html">scalable_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="9738de781dba5c37e5489657aac3a9c6"></a><!-- doxytag: member="tbb::operator!=" ref="9738de781dba5c37e5489657aac3a9c6" args="(const scalable_allocator&lt; T &gt; &amp;, const scalable_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00332.html">scalable_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00332.html">scalable_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aef1698b222ba9312ab24dcdcd98bbd8"></a><!-- doxytag: member="tbb::is_current_task_group_canceling" ref="aef1698b222ba9312ab24dcdcd98bbd8" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>is_current_task_group_canceling</b> ()</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="96f84056d7899a90d43b02871d9268c1"></a><!-- doxytag: member="tbb::make_task" ref="96f84056d7899a90d43b02871d9268c1" args="(const F &amp;f)" -->
template&lt;class F&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">task_handle&lt; F &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>make_task</b> (const F &amp;f)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="f51bacdb4a1e2ab08c55e64bb7bac1e6"></a><!-- doxytag: member="tbb::operator==" ref="f51bacdb4a1e2ab08c55e64bb7bac1e6" args="(const tbb_allocator&lt; T &gt; &amp;, const tbb_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00351.html">tbb_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00351.html">tbb_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="068cf2a2175e43e8c6b30d8b9965481a"></a><!-- doxytag: member="tbb::operator!=" ref="068cf2a2175e43e8c6b30d8b9965481a" args="(const tbb_allocator&lt; T &gt; &amp;, const tbb_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00351.html">tbb_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00351.html">tbb_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="28401e60d1f2989fb39d3c24f22165a1"></a><!-- doxytag: member="tbb::operator==" ref="28401e60d1f2989fb39d3c24f22165a1" args="(const zero_allocator&lt; T1, B1 &gt; &amp;a, const zero_allocator&lt; T2, B2 &gt; &amp;b)" -->
template&lt;typename T1, template&lt; typename X1 &gt; class B1, typename T2, template&lt; typename X2 &gt; class B2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00361.html">zero_allocator</a>&lt; T1, B1 &gt; &amp;a, const <a class="el" href="a00361.html">zero_allocator</a>&lt; T2, B2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="3b992dd773b8ae023abc4fe55948202a"></a><!-- doxytag: member="tbb::operator!=" ref="3b992dd773b8ae023abc4fe55948202a" args="(const zero_allocator&lt; T1, B1 &gt; &amp;a, const zero_allocator&lt; T2, B2 &gt; &amp;b)" -->
template&lt;typename T1, template&lt; typename X1 &gt; class B1, typename T2, template&lt; typename X2 &gt; class B2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00361.html">zero_allocator</a>&lt; T1, B1 &gt; &amp;a, const <a class="el" href="a00361.html">zero_allocator</a>&lt; T2, B2 &gt; &amp;b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="33e73b97b02726c692bd8d9da8e3fb1b"></a><!-- doxytag: member="tbb::atomic_fence" ref="33e73b97b02726c692bd8d9da8e3fb1b" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00423.html#33e73b97b02726c692bd8d9da8e3fb1b">atomic_fence</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sequentially consistent full memory fence. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00423.html#de8a8bc300d5ef09d38cbfb8baff5cd2">TBB_runtime_interface_version</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function returns the interface version of the TBB shared library being used.  <a href="#de8a8bc300d5ef09d38cbfb8baff5cd2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a037c1f149250d61cd2fad4541a5e6cb"></a><!-- doxytag: member="tbb::operator-" ref="a037c1f149250d61cd2fad4541a5e6cb" args="(const tick_count &amp;t1, const tick_count &amp;t0)" -->
<a class="el" href="a00358.html">tick_count::interval_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="a00357.html">tick_count</a> &amp;t1, const <a class="el" href="a00357.html">tick_count</a> &amp;t0)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The namespace tbb contains all components of the library. 
<p>
This header provides basic platform abstraction layer by hooking up appropriate architecture/OS/compiler specific headers from the /include/tbb/machine directory. If a plug-in header does not implement all the required APIs, it must specify the missing ones by setting one or more of the following macros:<p>
__TBB_USE_GENERIC_PART_WORD_CAS __TBB_USE_GENERIC_PART_WORD_FETCH_ADD __TBB_USE_GENERIC_PART_WORD_FETCH_STORE __TBB_USE_GENERIC_FETCH_ADD __TBB_USE_GENERIC_FETCH_STORE __TBB_USE_GENERIC_DWORD_FETCH_ADD __TBB_USE_GENERIC_DWORD_FETCH_STORE __TBB_USE_GENERIC_HALF_FENCED_LOAD_STORE __TBB_USE_GENERIC_FULL_FENCED_LOAD_STORE __TBB_USE_GENERIC_RELAXED_LOAD_STORE __TBB_USE_FETCHSTORE_AS_FULL_FENCED_STORE<p>
In this case <a class="el" href="a00656.html">tbb_machine.h</a> will add missing functionality based on a minimal set of APIs that are required to be implemented by all plug-n headers as described further. Note that these generic implementations may be sub-optimal for a particular architecture, and thus should be relied upon only after careful evaluation or as the last resort.<p>
Additionally __TBB_64BIT_ATOMICS can be set to 0 on a 32-bit architecture to indicate that the port is not going to support double word atomics. It may also be set to 1 explicitly, though normally this is not necessary as <a class="el" href="a00656.html">tbb_machine.h</a> will set it automatically.<p>
__TBB_BIG_ENDIAN macro can be defined by the implementation as well. It is used only if the __TBB_USE_GENERIC_PART_WORD_CAS is set. Possible values are:<ul>
<li>1 if the system is big endian,</li><li>0 if it is little endian,</li><li>or -1 to explicitly state that __TBB_USE_GENERIC_PART_WORD_CAS can not be used. -1 should be used when it is known in advance that endianness can change in run time or it is not simple big or little but something more complex. The system will try to detect it in run time if it is not set(in assumption that it is either a big or little one).</li></ul>
<p>
Prerequisites for each architecture port ---------------------------------------- The following functions and macros have no generic implementation. Therefore they must be implemented in each machine architecture specific header either as a conventional function or as a functional macro.<p>
__TBB_WORDSIZE This is the size of machine word in bytes, i.e. for 32 bit systems it should be defined to 4.<p>
__TBB_Yield() Signals OS that the current thread is willing to relinquish the remainder of its time quantum.<p>
__TBB_full_memory_fence() Must prevent all memory operations from being reordered across it (both by hardware and compiler). All such fences must be totally ordered (or sequentially consistent).<p>
__TBB_machine_cmpswp4( volatile void *ptr, int32_t value, int32_t comparand ) Must be provided if __TBB_USE_FENCED_ATOMICS is not set.<p>
__TBB_machine_cmpswp8( volatile void *ptr, int32_t value, int64_t comparand ) Must be provided for 64-bit architectures if __TBB_USE_FENCED_ATOMICS is not set, and for 32-bit architectures if __TBB_64BIT_ATOMICS is set<p>
__TBB_machine_&lt;op&gt;&lt;S&gt;&lt;fence&gt;(...), where &lt;op&gt; = {cmpswp, fetchadd, fetchstore} &lt;S&gt; = {1, 2, 4, 8} &lt;fence&gt; = {full_fence, acquire, release, relaxed} Must be provided if __TBB_USE_FENCED_ATOMICS is set.<p>
__TBB_control_consistency_helper() Bridges the memory-semantics gap between architectures providing only implicit C++0x "consume" semantics (like Power Architecture) and those also implicitly obeying control dependencies (like IA-64). It must be used only in conditional code where the condition is itself data-dependent, and will then make subsequent code behave as if the original data dependency were acquired. It needs only a compiler fence where implied by the architecture either specifically (like IA-64) or because generally stronger "acquire" semantics are enforced (like x86). It is always valid, though potentially suboptimal, to replace control with acquire on the load and then remove the helper.<p>
__TBB_acquire_consistency_helper(), __TBB_release_consistency_helper() Must be provided if __TBB_USE_GENERIC_HALF_FENCED_LOAD_STORE is set. Enforce acquire and release semantics in generic implementations of fenced store and load operations. Depending on the particular architecture/compiler combination they may be a hardware fence, a compiler fence, both or nothing. 
<p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="db86d08473679d6fe0eabcdc766ffe3a"></a><!-- doxytag: member="tbb::memory_semantics" ref="db86d08473679d6fe0eabcdc766ffe3a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00423.html#db86d08473679d6fe0eabcdc766ffe3a">tbb::memory_semantics</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specifies memory semantics. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="db86d08473679d6fe0eabcdc766ffe3a6a315190cf4509ec388ecb423432f36a"></a><!-- doxytag: member="full_fence" ref="db86d08473679d6fe0eabcdc766ffe3a6a315190cf4509ec388ecb423432f36a" args="" -->full_fence</em>&nbsp;</td><td>
Sequential consistency. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="db86d08473679d6fe0eabcdc766ffe3aa92646b4dc7618530d3a9f51dd10a418"></a><!-- doxytag: member="acquire" ref="db86d08473679d6fe0eabcdc766ffe3aa92646b4dc7618530d3a9f51dd10a418" args="" -->acquire</em>&nbsp;</td><td>
Acquire. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="db86d08473679d6fe0eabcdc766ffe3a412563418e657114a102db610f726632"></a><!-- doxytag: member="release" ref="db86d08473679d6fe0eabcdc766ffe3a412563418e657114a102db610f726632" args="" -->release</em>&nbsp;</td><td>
Release. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="db86d08473679d6fe0eabcdc766ffe3a73cb2e2bcb94442b8b2b72e93a76f2e5"></a><!-- doxytag: member="relaxed" ref="db86d08473679d6fe0eabcdc766ffe3a73cb2e2bcb94442b8b2b72e93a76f2e5" args="" -->relaxed</em>&nbsp;</td><td>
No ordering. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="de8a8bc300d5ef09d38cbfb8baff5cd2"></a><!-- doxytag: member="tbb::TBB_runtime_interface_version" ref="de8a8bc300d5ef09d38cbfb8baff5cd2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __TBB_EXPORTED_FUNC tbb::TBB_runtime_interface_version           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function returns the interface version of the TBB shared library being used. 
<p>
The version it returns is determined at runtime, not at compile/link time. So it can be different than the value of TBB_INTERFACE_VERSION obtained at compile time. 
</div>
</div><p>
<hr>
<p></p>
Copyright &copy; 2005-2012 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
