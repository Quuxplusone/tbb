<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>tbb::task_group_context Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="a00236.html">tbb</a>::<a class="el" href="a00149.html">task_group_context</a>
  </div>
</div>
<div class="contents">
<h1>tbb::task_group_context Class Reference<br/>
<small>
[<a class="el" href="a00254.html">Task Scheduling</a>]</small>
</h1><!-- doxytag: class="tbb::task_group_context" -->
<p>Used to form groups of tasks.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00201_source.html">parallel_invoke.h</a>&gt;</code></p>

<p><a href="a00281.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>kind_type</b> { <b>isolated</b>, 
<b>bound</b>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>traits_type</b> { <b>exact_exception</b> =  0x0001ul &lt;&lt; traits_offset, 
<b>concurrent_wait</b> =  0x0004ul &lt;&lt; traits_offset, 
<b>default_traits</b>
 }</td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00149.html#a7e770cd5f3e6546ba23ba2c961ad9216">task_group_context</a> (kind_type relation_with_parent=bound, uintptr_t traits=default_traits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default &amp; binding constructor.  <a href="#a7e770cd5f3e6546ba23ba2c961ad9216"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00149.html#af892e21ab275622d81c556214a4c877f">reset</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forcefully reinitializes the context after the <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> tree it was associated with is completed.  <a href="#af892e21ab275622d81c556214a4c877f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00149.html#a0d8cc8fa8a280a528700763b6aaba375">cancel_group_execution</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initiates cancellation of all tasks in this cancellation group and its subordinate groups.  <a href="#a0d8cc8fa8a280a528700763b6aaba375"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08021e5a97f6ffbf40a95f3f6b11f807"></a><!-- doxytag: member="tbb::task_group_context::is_group_execution_cancelled" ref="a08021e5a97f6ffbf40a95f3f6b11f807" args="() const " -->
bool __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00149.html#a08021e5a97f6ffbf40a95f3f6b11f807">is_group_execution_cancelled</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the context received cancellation request. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00149.html#a64a5938ce7cbab57a7345d3a373b94e6">register_pending_exception</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Records the pending exception, and cancels the <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> group.  <a href="#a64a5938ce7cbab57a7345d3a373b94e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2673f4725083c80a223743c9eb2cebf1"></a><!-- doxytag: member="tbb::task_group_context::set_priority" ref="a2673f4725083c80a223743c9eb2cebf1" args="(priority_t)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00149.html#a2673f4725083c80a223743c9eb2cebf1">set_priority</a> (priority_t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes priority of the <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> group. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60f3b7afc957b2407e3680308b5bcc79"></a><!-- doxytag: member="tbb::task_group_context::priority" ref="a60f3b7afc957b2407e3680308b5bcc79" args="() const " -->
priority_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00149.html#a60f3b7afc957b2407e3680308b5bcc79">priority</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves current priority of the current <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> group. <br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00149.html#ab5efe4aa41c3baab4ebda9db549e316b">init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Out-of-line part of the constructor.  <a href="#ab5efe4aa41c3baab4ebda9db549e316b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87ab0573846df9625350c0ce6f086bf1"></a><!-- doxytag: member="tbb::task_group_context::internal::generic_scheduler" ref="a87ab0573846df9625350c0ce6f086bf1" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::generic_scheduler</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afceb0c9960abffc60c85ac4cde4f3807"></a><!-- doxytag: member="tbb::task_group_context::task_scheduler_init" ref="afceb0c9960abffc60c85ac4cde4f3807" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>task_scheduler_init</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07ddcf513e260b5995e19229c3d9a019"></a><!-- doxytag: member="tbb::task_group_context::task" ref="a07ddcf513e260b5995e19229c3d9a019" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>task</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26855f4e884eee14d49f2ba7b8cd1dcf"></a><!-- doxytag: member="tbb::task_group_context::internal::allocate_root_with_context_proxy" ref="a26855f4e884eee14d49f2ba7b8cd1dcf" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::allocate_root_with_context_proxy</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Used to form groups of tasks. </p>
<p>Dummy to avoid cluttering the bulk of the header with enormous amount of ifdefs.</p>
<p>The context services explicit cancellation requests from user code, and unhandled exceptions intercepted during tasks execution. Intercepting an exception results in generating internal cancellation requests (which is processed in exactly the same way as external ones).</p>
<p>The context is associated with one or more root tasks and defines the cancellation group that includes all the descendants of the corresponding root task(s). Association is established when a context object is passed as an argument to the <a class="el" href="a00144.html#ac7a9405b422bec9110854acd71edb9f2" title="Returns proxy for overloaded new that allocates a root task.">task::allocate_root()</a> method. See <a class="el" href="a00149.html#a7e770cd5f3e6546ba23ba2c961ad9216" title="Default &amp; binding constructor.">task_group_context::task_group_context</a> for more details.</p>
<p>The context can be bound to another one, and other contexts can be bound to it, forming a tree-like structure: parent -&gt; this -&gt; children. Arrows here designate cancellation propagation direction. If a <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> in a cancellation group is cancelled all the other tasks in this group and groups bound to it (as children) get cancelled too.</p>
<p>IMPLEMENTATION NOTE: When adding new members to <a class="el" href="a00149.html" title="Used to form groups of tasks.">task_group_context</a> or changing types of existing ones, update the size of both padding buffers (_leading_padding and _trailing_padding) appropriately. See also VERSIONING NOTE at the constructor definition below. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7e770cd5f3e6546ba23ba2c961ad9216"></a><!-- doxytag: member="tbb::task_group_context::task_group_context" ref="a7e770cd5f3e6546ba23ba2c961ad9216" args="(kind_type relation_with_parent=bound, uintptr_t traits=default_traits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tbb::task_group_context::task_group_context </td>
          <td>(</td>
          <td class="paramtype">kind_type&nbsp;</td>
          <td class="paramname"> <em>relation_with_parent</em> = <code>bound</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&nbsp;</td>
          <td class="paramname"> <em>traits</em> = <code>default_traits</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default &amp; binding constructor. </p>
<p>By default a bound context is created. That is this context will be bound (as child) to the context of the <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> calling task::allocate_root(this_context) method. Cancellation requests passed to the parent context are propagated to all the contexts bound to it. Similarly priority change is propagated from the parent context to its children.</p>
<p>If task_group_context::isolated is used as the argument, then the tasks associated with this context will never be affected by events in any other context.</p>
<p>Creating isolated contexts involve much less overhead, but they have limited utility. Normally when an exception occurs in an algorithm that has nested ones running, it is desirably to have all the nested algorithms cancelled as well. Such a behavior requires nested algorithms to use bound contexts.</p>
<p>There is one good place where using isolated algorithms is beneficial. It is a master thread. That is if a particular algorithm is invoked directly from the master thread (not from a TBB <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a>), supplying it with explicitly created isolated context will result in a faster algorithm startup.</p>
<p>VERSIONING NOTE: Implementation(s) of <a class="el" href="a00149.html" title="Used to form groups of tasks.">task_group_context</a> constructor(s) cannot be made entirely out-of-line because the run-time version must be set by the user code. This will become critically important for binary compatibility, if we ever have to change the size of the context object.</p>
<p>Boosting the runtime version will also be necessary if new data fields are introduced in the currently unused padding areas and these fields are updated by inline methods. </p>

<p>References <a class="el" href="a00149.html#ab5efe4aa41c3baab4ebda9db549e316b">init()</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0d8cc8fa8a280a528700763b6aaba375"></a><!-- doxytag: member="tbb::task_group_context::cancel_group_execution" ref="a0d8cc8fa8a280a528700763b6aaba375" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool __TBB_EXPORTED_METHOD tbb::task_group_context::cancel_group_execution </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initiates cancellation of all tasks in this cancellation group and its subordinate groups. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if cancellation has already been requested, true otherwise.</dd></dl>
<p>Note that canceling never fails. When false is returned, it just means that another thread (or this one) has already sent cancellation request to this context or to one of its ancestors (if this context is bound). It is guaranteed that when this method is concurrently called on the same not yet cancelled context, true will be returned by one and only one invocation. </p>

</div>
</div>
<a class="anchor" id="ab5efe4aa41c3baab4ebda9db549e316b"></a><!-- doxytag: member="tbb::task_group_context::init" ref="ab5efe4aa41c3baab4ebda9db549e316b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __TBB_EXPORTED_METHOD tbb::task_group_context::init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Out-of-line part of the constructor. </p>
<p>Singled out to ensure backward binary compatibility of the future versions. </p>

<p>Referenced by <a class="el" href="a00216_source.html#l00435">task_group_context()</a>.</p>

</div>
</div>
<a class="anchor" id="a64a5938ce7cbab57a7345d3a373b94e6"></a><!-- doxytag: member="tbb::task_group_context::register_pending_exception" ref="a64a5938ce7cbab57a7345d3a373b94e6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __TBB_EXPORTED_METHOD tbb::task_group_context::register_pending_exception </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Records the pending exception, and cancels the <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> group. </p>
<p>May be called only from inside a catch-block. If the context is already cancelled, does nothing. The method brings the <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> group associated with this context exactly into the state it would be in, if one of its tasks threw the currently pending exception during its execution. In other words, it emulates the actions of the scheduler's dispatch loop exception handler. </p>

</div>
</div>
<a class="anchor" id="af892e21ab275622d81c556214a4c877f"></a><!-- doxytag: member="tbb::task_group_context::reset" ref="af892e21ab275622d81c556214a4c877f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __TBB_EXPORTED_METHOD tbb::task_group_context::reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Forcefully reinitializes the context after the <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> tree it was associated with is completed. </p>
<p>Because the method assumes that all the tasks that used to be associated with this context have already finished, calling it while the context is still in use somewhere in the <a class="el" href="a00144.html" title="Base class for user-defined tasks.">task</a> hierarchy leads to undefined behavior.</p>
<p>IMPORTANT: This method is not thread safe!</p>
<p>The method does not change the context's parent if it is set. </p>

<p>Referenced by <a class="el" href="a00193_source.html#l00438">tbb::flow::interface6::graph::wait_for_all()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="a00201_source.html">parallel_invoke.h</a></li>
<li><a class="el" href="a00216_source.html">task.h</a></li>
</ul>
</div>
<hr>
<p></p>
Copyright &copy; 2005-2013 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
